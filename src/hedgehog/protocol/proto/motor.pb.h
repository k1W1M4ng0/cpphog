// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hedgehog/protocol/proto/motor.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_hedgehog_2fprotocol_2fproto_2fmotor_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_hedgehog_2fprotocol_2fproto_2fmotor_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "hedgehog/protocol/proto/subscription.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_hedgehog_2fprotocol_2fproto_2fmotor_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_hedgehog_2fprotocol_2fproto_2fmotor_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_hedgehog_2fprotocol_2fproto_2fmotor_2eproto;
namespace hedgehog {
namespace protocol {
namespace proto {
class DcConfig;
struct DcConfigDefaultTypeInternal;
extern DcConfigDefaultTypeInternal _DcConfig_default_instance_;
class EncoderConfig;
struct EncoderConfigDefaultTypeInternal;
extern EncoderConfigDefaultTypeInternal _EncoderConfig_default_instance_;
class MotorAction;
struct MotorActionDefaultTypeInternal;
extern MotorActionDefaultTypeInternal _MotorAction_default_instance_;
class MotorCommandMessage;
struct MotorCommandMessageDefaultTypeInternal;
extern MotorCommandMessageDefaultTypeInternal _MotorCommandMessage_default_instance_;
class MotorConfigAction;
struct MotorConfigActionDefaultTypeInternal;
extern MotorConfigActionDefaultTypeInternal _MotorConfigAction_default_instance_;
class MotorSetPositionAction;
struct MotorSetPositionActionDefaultTypeInternal;
extern MotorSetPositionActionDefaultTypeInternal _MotorSetPositionAction_default_instance_;
class MotorStateMessage;
struct MotorStateMessageDefaultTypeInternal;
extern MotorStateMessageDefaultTypeInternal _MotorStateMessage_default_instance_;
class StepperConfig;
struct StepperConfigDefaultTypeInternal;
extern StepperConfigDefaultTypeInternal _StepperConfig_default_instance_;
}  // namespace proto
}  // namespace protocol
}  // namespace hedgehog
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace hedgehog {
namespace protocol {
namespace proto {
enum MotorState : int {
  POWER = 0,
  BRAKE = 1,
  VELOCITY = 2,
  MotorState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MotorState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MotorState_IsValid(int value);
extern const uint32_t MotorState_internal_data_[];
constexpr MotorState MotorState_MIN = static_cast<MotorState>(0);
constexpr MotorState MotorState_MAX = static_cast<MotorState>(2);
constexpr int MotorState_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
MotorState_descriptor();
template <typename T>
const std::string& MotorState_Name(T value) {
  static_assert(std::is_same<T, MotorState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MotorState_Name().");
  return MotorState_Name(static_cast<MotorState>(value));
}
template <>
inline const std::string& MotorState_Name(MotorState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MotorState_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool MotorState_Parse(absl::string_view name, MotorState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotorState>(
      MotorState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class StepperConfig final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.StepperConfig) */ {
 public:
  inline StepperConfig() : StepperConfig(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StepperConfig(::google::protobuf::internal::ConstantInitialized);

  inline StepperConfig(const StepperConfig& from)
      : StepperConfig(nullptr, from) {}
  StepperConfig(StepperConfig&& from) noexcept
    : StepperConfig() {
    *this = ::std::move(from);
  }

  inline StepperConfig& operator=(const StepperConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepperConfig& operator=(StepperConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepperConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepperConfig* internal_default_instance() {
    return reinterpret_cast<const StepperConfig*>(
               &_StepperConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StepperConfig& a, StepperConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StepperConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepperConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepperConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepperConfig>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StepperConfig& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StepperConfig& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.StepperConfig";
  }
  protected:
  explicit StepperConfig(::google::protobuf::Arena* arena);
  StepperConfig(::google::protobuf::Arena* arena, const StepperConfig& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.StepperConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fmotor_2eproto;
};// -------------------------------------------------------------------

class MotorSetPositionAction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.MotorSetPositionAction) */ {
 public:
  inline MotorSetPositionAction() : MotorSetPositionAction(nullptr) {}
  ~MotorSetPositionAction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MotorSetPositionAction(::google::protobuf::internal::ConstantInitialized);

  inline MotorSetPositionAction(const MotorSetPositionAction& from)
      : MotorSetPositionAction(nullptr, from) {}
  MotorSetPositionAction(MotorSetPositionAction&& from) noexcept
    : MotorSetPositionAction() {
    *this = ::std::move(from);
  }

  inline MotorSetPositionAction& operator=(const MotorSetPositionAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorSetPositionAction& operator=(MotorSetPositionAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorSetPositionAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotorSetPositionAction* internal_default_instance() {
    return reinterpret_cast<const MotorSetPositionAction*>(
               &_MotorSetPositionAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MotorSetPositionAction& a, MotorSetPositionAction& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorSetPositionAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorSetPositionAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotorSetPositionAction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotorSetPositionAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MotorSetPositionAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MotorSetPositionAction& from) {
    MotorSetPositionAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MotorSetPositionAction* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.MotorSetPositionAction";
  }
  protected:
  explicit MotorSetPositionAction(::google::protobuf::Arena* arena);
  MotorSetPositionAction(::google::protobuf::Arena* arena, const MotorSetPositionAction& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 1,
    kPositionFieldNumber = 2,
  };
  // uint32 port = 1;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // sint32 position = 2;
  void clear_position() ;
  ::int32_t position() const;
  void set_position(::int32_t value);

  private:
  ::int32_t _internal_position() const;
  void _internal_set_position(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.MotorSetPositionAction)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t port_;
    ::int32_t position_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fmotor_2eproto;
};// -------------------------------------------------------------------

class MotorAction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.MotorAction) */ {
 public:
  inline MotorAction() : MotorAction(nullptr) {}
  ~MotorAction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MotorAction(::google::protobuf::internal::ConstantInitialized);

  inline MotorAction(const MotorAction& from)
      : MotorAction(nullptr, from) {}
  MotorAction(MotorAction&& from) noexcept
    : MotorAction() {
    *this = ::std::move(from);
  }

  inline MotorAction& operator=(const MotorAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorAction& operator=(MotorAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorAction& default_instance() {
    return *internal_default_instance();
  }
  enum PositionCase {
    kRelative = 5,
    kAbsolute = 6,
    POSITION_NOT_SET = 0,
  };

  static inline const MotorAction* internal_default_instance() {
    return reinterpret_cast<const MotorAction*>(
               &_MotorAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MotorAction& a, MotorAction& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotorAction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotorAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MotorAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MotorAction& from) {
    MotorAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MotorAction* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.MotorAction";
  }
  protected:
  explicit MotorAction(::google::protobuf::Arena* arena);
  MotorAction(::google::protobuf::Arena* arena, const MotorAction& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 1,
    kStateFieldNumber = 2,
    kAmountFieldNumber = 3,
    kReachedStateFieldNumber = 4,
    kRelativeFieldNumber = 5,
    kAbsoluteFieldNumber = 6,
  };
  // uint32 port = 1;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // .hedgehog.protocol.proto.MotorState state = 2;
  void clear_state() ;
  ::hedgehog::protocol::proto::MotorState state() const;
  void set_state(::hedgehog::protocol::proto::MotorState value);

  private:
  ::hedgehog::protocol::proto::MotorState _internal_state() const;
  void _internal_set_state(::hedgehog::protocol::proto::MotorState value);

  public:
  // sint32 amount = 3;
  void clear_amount() ;
  ::int32_t amount() const;
  void set_amount(::int32_t value);

  private:
  ::int32_t _internal_amount() const;
  void _internal_set_amount(::int32_t value);

  public:
  // .hedgehog.protocol.proto.MotorState reached_state = 4;
  void clear_reached_state() ;
  ::hedgehog::protocol::proto::MotorState reached_state() const;
  void set_reached_state(::hedgehog::protocol::proto::MotorState value);

  private:
  ::hedgehog::protocol::proto::MotorState _internal_reached_state() const;
  void _internal_set_reached_state(::hedgehog::protocol::proto::MotorState value);

  public:
  // sint32 relative = 5;
  bool has_relative() const;
  void clear_relative() ;
  ::int32_t relative() const;
  void set_relative(::int32_t value);

  private:
  ::int32_t _internal_relative() const;
  void _internal_set_relative(::int32_t value);

  public:
  // sint32 absolute = 6;
  bool has_absolute() const;
  void clear_absolute() ;
  ::int32_t absolute() const;
  void set_absolute(::int32_t value);

  private:
  ::int32_t _internal_absolute() const;
  void _internal_set_absolute(::int32_t value);

  public:
  void clear_position();
  PositionCase position_case() const;
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.MotorAction)
 private:
  class _Internal;
  void set_has_relative();
  void set_has_absolute();

  inline bool has_position() const;
  inline void clear_has_position();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t port_;
    int state_;
    ::int32_t amount_;
    int reached_state_;
    union PositionUnion {
      constexpr PositionUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t relative_;
      ::int32_t absolute_;
    } position_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fmotor_2eproto;
};// -------------------------------------------------------------------

class EncoderConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.EncoderConfig) */ {
 public:
  inline EncoderConfig() : EncoderConfig(nullptr) {}
  ~EncoderConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EncoderConfig(::google::protobuf::internal::ConstantInitialized);

  inline EncoderConfig(const EncoderConfig& from)
      : EncoderConfig(nullptr, from) {}
  EncoderConfig(EncoderConfig&& from) noexcept
    : EncoderConfig() {
    *this = ::std::move(from);
  }

  inline EncoderConfig& operator=(const EncoderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncoderConfig& operator=(EncoderConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncoderConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncoderConfig* internal_default_instance() {
    return reinterpret_cast<const EncoderConfig*>(
               &_EncoderConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EncoderConfig& a, EncoderConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(EncoderConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncoderConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncoderConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EncoderConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EncoderConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EncoderConfig& from) {
    EncoderConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EncoderConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.EncoderConfig";
  }
  protected:
  explicit EncoderConfig(::google::protobuf::Arena* arena);
  EncoderConfig(::google::protobuf::Arena* arena, const EncoderConfig& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncoderAPortFieldNumber = 1,
    kEncoderBPortFieldNumber = 2,
  };
  // uint32 encoder_a_port = 1;
  void clear_encoder_a_port() ;
  ::uint32_t encoder_a_port() const;
  void set_encoder_a_port(::uint32_t value);

  private:
  ::uint32_t _internal_encoder_a_port() const;
  void _internal_set_encoder_a_port(::uint32_t value);

  public:
  // uint32 encoder_b_port = 2;
  void clear_encoder_b_port() ;
  ::uint32_t encoder_b_port() const;
  void set_encoder_b_port(::uint32_t value);

  private:
  ::uint32_t _internal_encoder_b_port() const;
  void _internal_set_encoder_b_port(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.EncoderConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t encoder_a_port_;
    ::uint32_t encoder_b_port_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fmotor_2eproto;
};// -------------------------------------------------------------------

class DcConfig final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.DcConfig) */ {
 public:
  inline DcConfig() : DcConfig(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DcConfig(::google::protobuf::internal::ConstantInitialized);

  inline DcConfig(const DcConfig& from)
      : DcConfig(nullptr, from) {}
  DcConfig(DcConfig&& from) noexcept
    : DcConfig() {
    *this = ::std::move(from);
  }

  inline DcConfig& operator=(const DcConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DcConfig& operator=(DcConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DcConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const DcConfig* internal_default_instance() {
    return reinterpret_cast<const DcConfig*>(
               &_DcConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DcConfig& a, DcConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DcConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DcConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DcConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DcConfig>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DcConfig& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DcConfig& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.DcConfig";
  }
  protected:
  explicit DcConfig(::google::protobuf::Arena* arena);
  DcConfig(::google::protobuf::Arena* arena, const DcConfig& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.DcConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fmotor_2eproto;
};// -------------------------------------------------------------------

class MotorStateMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.MotorStateMessage) */ {
 public:
  inline MotorStateMessage() : MotorStateMessage(nullptr) {}
  ~MotorStateMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MotorStateMessage(::google::protobuf::internal::ConstantInitialized);

  inline MotorStateMessage(const MotorStateMessage& from)
      : MotorStateMessage(nullptr, from) {}
  MotorStateMessage(MotorStateMessage&& from) noexcept
    : MotorStateMessage() {
    *this = ::std::move(from);
  }

  inline MotorStateMessage& operator=(const MotorStateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorStateMessage& operator=(MotorStateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorStateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotorStateMessage* internal_default_instance() {
    return reinterpret_cast<const MotorStateMessage*>(
               &_MotorStateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MotorStateMessage& a, MotorStateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorStateMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorStateMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotorStateMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotorStateMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MotorStateMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MotorStateMessage& from) {
    MotorStateMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MotorStateMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.MotorStateMessage";
  }
  protected:
  explicit MotorStateMessage(::google::protobuf::Arena* arena);
  MotorStateMessage(::google::protobuf::Arena* arena, const MotorStateMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionFieldNumber = 4,
    kPortFieldNumber = 1,
    kVelocityFieldNumber = 2,
    kPositionFieldNumber = 3,
  };
  // .hedgehog.protocol.proto.Subscription subscription = 4;
  bool has_subscription() const;
  void clear_subscription() ;
  const ::hedgehog::protocol::proto::Subscription& subscription() const;
  PROTOBUF_NODISCARD ::hedgehog::protocol::proto::Subscription* release_subscription();
  ::hedgehog::protocol::proto::Subscription* mutable_subscription();
  void set_allocated_subscription(::hedgehog::protocol::proto::Subscription* value);
  void unsafe_arena_set_allocated_subscription(::hedgehog::protocol::proto::Subscription* value);
  ::hedgehog::protocol::proto::Subscription* unsafe_arena_release_subscription();

  private:
  const ::hedgehog::protocol::proto::Subscription& _internal_subscription() const;
  ::hedgehog::protocol::proto::Subscription* _internal_mutable_subscription();

  public:
  // uint32 port = 1;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // sint32 velocity = 2;
  void clear_velocity() ;
  ::int32_t velocity() const;
  void set_velocity(::int32_t value);

  private:
  ::int32_t _internal_velocity() const;
  void _internal_set_velocity(::int32_t value);

  public:
  // sint32 position = 3;
  void clear_position() ;
  ::int32_t position() const;
  void set_position(::int32_t value);

  private:
  ::int32_t _internal_position() const;
  void _internal_set_position(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.MotorStateMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::hedgehog::protocol::proto::Subscription* subscription_;
    ::uint32_t port_;
    ::int32_t velocity_;
    ::int32_t position_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fmotor_2eproto;
};// -------------------------------------------------------------------

class MotorConfigAction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.MotorConfigAction) */ {
 public:
  inline MotorConfigAction() : MotorConfigAction(nullptr) {}
  ~MotorConfigAction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MotorConfigAction(::google::protobuf::internal::ConstantInitialized);

  inline MotorConfigAction(const MotorConfigAction& from)
      : MotorConfigAction(nullptr, from) {}
  MotorConfigAction(MotorConfigAction&& from) noexcept
    : MotorConfigAction() {
    *this = ::std::move(from);
  }

  inline MotorConfigAction& operator=(const MotorConfigAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorConfigAction& operator=(MotorConfigAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorConfigAction& default_instance() {
    return *internal_default_instance();
  }
  enum ConfigCase {
    kDc = 2,
    kEncoder = 3,
    kStepper = 4,
    CONFIG_NOT_SET = 0,
  };

  static inline const MotorConfigAction* internal_default_instance() {
    return reinterpret_cast<const MotorConfigAction*>(
               &_MotorConfigAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MotorConfigAction& a, MotorConfigAction& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorConfigAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorConfigAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotorConfigAction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotorConfigAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MotorConfigAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MotorConfigAction& from) {
    MotorConfigAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MotorConfigAction* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.MotorConfigAction";
  }
  protected:
  explicit MotorConfigAction(::google::protobuf::Arena* arena);
  MotorConfigAction(::google::protobuf::Arena* arena, const MotorConfigAction& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 1,
    kDcFieldNumber = 2,
    kEncoderFieldNumber = 3,
    kStepperFieldNumber = 4,
  };
  // uint32 port = 1;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // .hedgehog.protocol.proto.DcConfig dc = 2;
  bool has_dc() const;
  private:
  bool _internal_has_dc() const;

  public:
  void clear_dc() ;
  const ::hedgehog::protocol::proto::DcConfig& dc() const;
  PROTOBUF_NODISCARD ::hedgehog::protocol::proto::DcConfig* release_dc();
  ::hedgehog::protocol::proto::DcConfig* mutable_dc();
  void set_allocated_dc(::hedgehog::protocol::proto::DcConfig* value);
  void unsafe_arena_set_allocated_dc(::hedgehog::protocol::proto::DcConfig* value);
  ::hedgehog::protocol::proto::DcConfig* unsafe_arena_release_dc();

  private:
  const ::hedgehog::protocol::proto::DcConfig& _internal_dc() const;
  ::hedgehog::protocol::proto::DcConfig* _internal_mutable_dc();

  public:
  // .hedgehog.protocol.proto.EncoderConfig encoder = 3;
  bool has_encoder() const;
  private:
  bool _internal_has_encoder() const;

  public:
  void clear_encoder() ;
  const ::hedgehog::protocol::proto::EncoderConfig& encoder() const;
  PROTOBUF_NODISCARD ::hedgehog::protocol::proto::EncoderConfig* release_encoder();
  ::hedgehog::protocol::proto::EncoderConfig* mutable_encoder();
  void set_allocated_encoder(::hedgehog::protocol::proto::EncoderConfig* value);
  void unsafe_arena_set_allocated_encoder(::hedgehog::protocol::proto::EncoderConfig* value);
  ::hedgehog::protocol::proto::EncoderConfig* unsafe_arena_release_encoder();

  private:
  const ::hedgehog::protocol::proto::EncoderConfig& _internal_encoder() const;
  ::hedgehog::protocol::proto::EncoderConfig* _internal_mutable_encoder();

  public:
  // .hedgehog.protocol.proto.StepperConfig stepper = 4;
  bool has_stepper() const;
  private:
  bool _internal_has_stepper() const;

  public:
  void clear_stepper() ;
  const ::hedgehog::protocol::proto::StepperConfig& stepper() const;
  PROTOBUF_NODISCARD ::hedgehog::protocol::proto::StepperConfig* release_stepper();
  ::hedgehog::protocol::proto::StepperConfig* mutable_stepper();
  void set_allocated_stepper(::hedgehog::protocol::proto::StepperConfig* value);
  void unsafe_arena_set_allocated_stepper(::hedgehog::protocol::proto::StepperConfig* value);
  ::hedgehog::protocol::proto::StepperConfig* unsafe_arena_release_stepper();

  private:
  const ::hedgehog::protocol::proto::StepperConfig& _internal_stepper() const;
  ::hedgehog::protocol::proto::StepperConfig* _internal_mutable_stepper();

  public:
  void clear_config();
  ConfigCase config_case() const;
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.MotorConfigAction)
 private:
  class _Internal;
  void set_has_dc();
  void set_has_encoder();
  void set_has_stepper();

  inline bool has_config() const;
  inline void clear_has_config();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t port_;
    union ConfigUnion {
      constexpr ConfigUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::hedgehog::protocol::proto::DcConfig* dc_;
      ::hedgehog::protocol::proto::EncoderConfig* encoder_;
      ::hedgehog::protocol::proto::StepperConfig* stepper_;
    } config_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fmotor_2eproto;
};// -------------------------------------------------------------------

class MotorCommandMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.MotorCommandMessage) */ {
 public:
  inline MotorCommandMessage() : MotorCommandMessage(nullptr) {}
  ~MotorCommandMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MotorCommandMessage(::google::protobuf::internal::ConstantInitialized);

  inline MotorCommandMessage(const MotorCommandMessage& from)
      : MotorCommandMessage(nullptr, from) {}
  MotorCommandMessage(MotorCommandMessage&& from) noexcept
    : MotorCommandMessage() {
    *this = ::std::move(from);
  }

  inline MotorCommandMessage& operator=(const MotorCommandMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorCommandMessage& operator=(MotorCommandMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorCommandMessage& default_instance() {
    return *internal_default_instance();
  }
  enum ConfigCase {
    kDc = 5,
    kEncoder = 6,
    kStepper = 7,
    CONFIG_NOT_SET = 0,
  };

  static inline const MotorCommandMessage* internal_default_instance() {
    return reinterpret_cast<const MotorCommandMessage*>(
               &_MotorCommandMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MotorCommandMessage& a, MotorCommandMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorCommandMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorCommandMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotorCommandMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotorCommandMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MotorCommandMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MotorCommandMessage& from) {
    MotorCommandMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MotorCommandMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.MotorCommandMessage";
  }
  protected:
  explicit MotorCommandMessage(::google::protobuf::Arena* arena);
  MotorCommandMessage(::google::protobuf::Arena* arena, const MotorCommandMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionFieldNumber = 4,
    kPortFieldNumber = 1,
    kStateFieldNumber = 2,
    kAmountFieldNumber = 3,
    kDcFieldNumber = 5,
    kEncoderFieldNumber = 6,
    kStepperFieldNumber = 7,
  };
  // .hedgehog.protocol.proto.Subscription subscription = 4;
  bool has_subscription() const;
  void clear_subscription() ;
  const ::hedgehog::protocol::proto::Subscription& subscription() const;
  PROTOBUF_NODISCARD ::hedgehog::protocol::proto::Subscription* release_subscription();
  ::hedgehog::protocol::proto::Subscription* mutable_subscription();
  void set_allocated_subscription(::hedgehog::protocol::proto::Subscription* value);
  void unsafe_arena_set_allocated_subscription(::hedgehog::protocol::proto::Subscription* value);
  ::hedgehog::protocol::proto::Subscription* unsafe_arena_release_subscription();

  private:
  const ::hedgehog::protocol::proto::Subscription& _internal_subscription() const;
  ::hedgehog::protocol::proto::Subscription* _internal_mutable_subscription();

  public:
  // uint32 port = 1;
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // .hedgehog.protocol.proto.MotorState state = 2;
  void clear_state() ;
  ::hedgehog::protocol::proto::MotorState state() const;
  void set_state(::hedgehog::protocol::proto::MotorState value);

  private:
  ::hedgehog::protocol::proto::MotorState _internal_state() const;
  void _internal_set_state(::hedgehog::protocol::proto::MotorState value);

  public:
  // sint32 amount = 3;
  void clear_amount() ;
  ::int32_t amount() const;
  void set_amount(::int32_t value);

  private:
  ::int32_t _internal_amount() const;
  void _internal_set_amount(::int32_t value);

  public:
  // .hedgehog.protocol.proto.DcConfig dc = 5;
  bool has_dc() const;
  private:
  bool _internal_has_dc() const;

  public:
  void clear_dc() ;
  const ::hedgehog::protocol::proto::DcConfig& dc() const;
  PROTOBUF_NODISCARD ::hedgehog::protocol::proto::DcConfig* release_dc();
  ::hedgehog::protocol::proto::DcConfig* mutable_dc();
  void set_allocated_dc(::hedgehog::protocol::proto::DcConfig* value);
  void unsafe_arena_set_allocated_dc(::hedgehog::protocol::proto::DcConfig* value);
  ::hedgehog::protocol::proto::DcConfig* unsafe_arena_release_dc();

  private:
  const ::hedgehog::protocol::proto::DcConfig& _internal_dc() const;
  ::hedgehog::protocol::proto::DcConfig* _internal_mutable_dc();

  public:
  // .hedgehog.protocol.proto.EncoderConfig encoder = 6;
  bool has_encoder() const;
  private:
  bool _internal_has_encoder() const;

  public:
  void clear_encoder() ;
  const ::hedgehog::protocol::proto::EncoderConfig& encoder() const;
  PROTOBUF_NODISCARD ::hedgehog::protocol::proto::EncoderConfig* release_encoder();
  ::hedgehog::protocol::proto::EncoderConfig* mutable_encoder();
  void set_allocated_encoder(::hedgehog::protocol::proto::EncoderConfig* value);
  void unsafe_arena_set_allocated_encoder(::hedgehog::protocol::proto::EncoderConfig* value);
  ::hedgehog::protocol::proto::EncoderConfig* unsafe_arena_release_encoder();

  private:
  const ::hedgehog::protocol::proto::EncoderConfig& _internal_encoder() const;
  ::hedgehog::protocol::proto::EncoderConfig* _internal_mutable_encoder();

  public:
  // .hedgehog.protocol.proto.StepperConfig stepper = 7;
  bool has_stepper() const;
  private:
  bool _internal_has_stepper() const;

  public:
  void clear_stepper() ;
  const ::hedgehog::protocol::proto::StepperConfig& stepper() const;
  PROTOBUF_NODISCARD ::hedgehog::protocol::proto::StepperConfig* release_stepper();
  ::hedgehog::protocol::proto::StepperConfig* mutable_stepper();
  void set_allocated_stepper(::hedgehog::protocol::proto::StepperConfig* value);
  void unsafe_arena_set_allocated_stepper(::hedgehog::protocol::proto::StepperConfig* value);
  ::hedgehog::protocol::proto::StepperConfig* unsafe_arena_release_stepper();

  private:
  const ::hedgehog::protocol::proto::StepperConfig& _internal_stepper() const;
  ::hedgehog::protocol::proto::StepperConfig* _internal_mutable_stepper();

  public:
  void clear_config();
  ConfigCase config_case() const;
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.MotorCommandMessage)
 private:
  class _Internal;
  void set_has_dc();
  void set_has_encoder();
  void set_has_stepper();

  inline bool has_config() const;
  inline void clear_has_config();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 7, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::hedgehog::protocol::proto::Subscription* subscription_;
    ::uint32_t port_;
    int state_;
    ::int32_t amount_;
    union ConfigUnion {
      constexpr ConfigUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::hedgehog::protocol::proto::DcConfig* dc_;
      ::hedgehog::protocol::proto::EncoderConfig* encoder_;
      ::hedgehog::protocol::proto::StepperConfig* stepper_;
    } config_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fmotor_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// DcConfig

// -------------------------------------------------------------------

// EncoderConfig

// uint32 encoder_a_port = 1;
inline void EncoderConfig::clear_encoder_a_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encoder_a_port_ = 0u;
}
inline ::uint32_t EncoderConfig::encoder_a_port() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.EncoderConfig.encoder_a_port)
  return _internal_encoder_a_port();
}
inline void EncoderConfig::set_encoder_a_port(::uint32_t value) {
  _internal_set_encoder_a_port(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.EncoderConfig.encoder_a_port)
}
inline ::uint32_t EncoderConfig::_internal_encoder_a_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.encoder_a_port_;
}
inline void EncoderConfig::_internal_set_encoder_a_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.encoder_a_port_ = value;
}

// uint32 encoder_b_port = 2;
inline void EncoderConfig::clear_encoder_b_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encoder_b_port_ = 0u;
}
inline ::uint32_t EncoderConfig::encoder_b_port() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.EncoderConfig.encoder_b_port)
  return _internal_encoder_b_port();
}
inline void EncoderConfig::set_encoder_b_port(::uint32_t value) {
  _internal_set_encoder_b_port(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.EncoderConfig.encoder_b_port)
}
inline ::uint32_t EncoderConfig::_internal_encoder_b_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.encoder_b_port_;
}
inline void EncoderConfig::_internal_set_encoder_b_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.encoder_b_port_ = value;
}

// -------------------------------------------------------------------

// StepperConfig

// -------------------------------------------------------------------

// MotorAction

// uint32 port = 1;
inline void MotorAction::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0u;
}
inline ::uint32_t MotorAction::port() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorAction.port)
  return _internal_port();
}
inline void MotorAction::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorAction.port)
}
inline ::uint32_t MotorAction::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void MotorAction::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// .hedgehog.protocol.proto.MotorState state = 2;
inline void MotorAction::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
}
inline ::hedgehog::protocol::proto::MotorState MotorAction::state() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorAction.state)
  return _internal_state();
}
inline void MotorAction::set_state(::hedgehog::protocol::proto::MotorState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorAction.state)
}
inline ::hedgehog::protocol::proto::MotorState MotorAction::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::hedgehog::protocol::proto::MotorState>(_impl_.state_);
}
inline void MotorAction::_internal_set_state(::hedgehog::protocol::proto::MotorState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// sint32 amount = 3;
inline void MotorAction::clear_amount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.amount_ = 0;
}
inline ::int32_t MotorAction::amount() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorAction.amount)
  return _internal_amount();
}
inline void MotorAction::set_amount(::int32_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorAction.amount)
}
inline ::int32_t MotorAction::_internal_amount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.amount_;
}
inline void MotorAction::_internal_set_amount(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.amount_ = value;
}

// .hedgehog.protocol.proto.MotorState reached_state = 4;
inline void MotorAction::clear_reached_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reached_state_ = 0;
}
inline ::hedgehog::protocol::proto::MotorState MotorAction::reached_state() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorAction.reached_state)
  return _internal_reached_state();
}
inline void MotorAction::set_reached_state(::hedgehog::protocol::proto::MotorState value) {
  _internal_set_reached_state(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorAction.reached_state)
}
inline ::hedgehog::protocol::proto::MotorState MotorAction::_internal_reached_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::hedgehog::protocol::proto::MotorState>(_impl_.reached_state_);
}
inline void MotorAction::_internal_set_reached_state(::hedgehog::protocol::proto::MotorState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reached_state_ = value;
}

// sint32 relative = 5;
inline bool MotorAction::has_relative() const {
  return position_case() == kRelative;
}
inline void MotorAction::set_has_relative() {
  _impl_._oneof_case_[0] = kRelative;
}
inline void MotorAction::clear_relative() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (position_case() == kRelative) {
    _impl_.position_.relative_ = 0;
    clear_has_position();
  }
}
inline ::int32_t MotorAction::relative() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorAction.relative)
  return _internal_relative();
}
inline void MotorAction::set_relative(::int32_t value) {
  _internal_set_relative(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorAction.relative)
}
inline ::int32_t MotorAction::_internal_relative() const {
  if (position_case() == kRelative) {
    return _impl_.position_.relative_;
  }
  return 0;
}
inline void MotorAction::_internal_set_relative(::int32_t value) {
  if (position_case() != kRelative) {
    clear_position();
    set_has_relative();
  }
  _impl_.position_.relative_ = value;
}

// sint32 absolute = 6;
inline bool MotorAction::has_absolute() const {
  return position_case() == kAbsolute;
}
inline void MotorAction::set_has_absolute() {
  _impl_._oneof_case_[0] = kAbsolute;
}
inline void MotorAction::clear_absolute() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (position_case() == kAbsolute) {
    _impl_.position_.absolute_ = 0;
    clear_has_position();
  }
}
inline ::int32_t MotorAction::absolute() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorAction.absolute)
  return _internal_absolute();
}
inline void MotorAction::set_absolute(::int32_t value) {
  _internal_set_absolute(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorAction.absolute)
}
inline ::int32_t MotorAction::_internal_absolute() const {
  if (position_case() == kAbsolute) {
    return _impl_.position_.absolute_;
  }
  return 0;
}
inline void MotorAction::_internal_set_absolute(::int32_t value) {
  if (position_case() != kAbsolute) {
    clear_position();
    set_has_absolute();
  }
  _impl_.position_.absolute_ = value;
}

inline bool MotorAction::has_position() const {
  return position_case() != POSITION_NOT_SET;
}
inline void MotorAction::clear_has_position() {
  _impl_._oneof_case_[0] = POSITION_NOT_SET;
}
inline MotorAction::PositionCase MotorAction::position_case() const {
  return MotorAction::PositionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MotorConfigAction

// uint32 port = 1;
inline void MotorConfigAction::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0u;
}
inline ::uint32_t MotorConfigAction::port() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorConfigAction.port)
  return _internal_port();
}
inline void MotorConfigAction::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorConfigAction.port)
}
inline ::uint32_t MotorConfigAction::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void MotorConfigAction::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// .hedgehog.protocol.proto.DcConfig dc = 2;
inline bool MotorConfigAction::has_dc() const {
  return config_case() == kDc;
}
inline bool MotorConfigAction::_internal_has_dc() const {
  return config_case() == kDc;
}
inline void MotorConfigAction::set_has_dc() {
  _impl_._oneof_case_[0] = kDc;
}
inline void MotorConfigAction::clear_dc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (config_case() == kDc) {
    if (GetArena() == nullptr) {
      delete _impl_.config_.dc_;
    }
    clear_has_config();
  }
}
inline ::hedgehog::protocol::proto::DcConfig* MotorConfigAction::release_dc() {
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.MotorConfigAction.dc)
  if (config_case() == kDc) {
    clear_has_config();
    auto* temp = _impl_.config_.dc_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.dc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hedgehog::protocol::proto::DcConfig& MotorConfigAction::_internal_dc() const {
  return config_case() == kDc ? *_impl_.config_.dc_ : reinterpret_cast<::hedgehog::protocol::proto::DcConfig&>(::hedgehog::protocol::proto::_DcConfig_default_instance_);
}
inline const ::hedgehog::protocol::proto::DcConfig& MotorConfigAction::dc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorConfigAction.dc)
  return _internal_dc();
}
inline ::hedgehog::protocol::proto::DcConfig* MotorConfigAction::unsafe_arena_release_dc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hedgehog.protocol.proto.MotorConfigAction.dc)
  if (config_case() == kDc) {
    clear_has_config();
    auto* temp = _impl_.config_.dc_;
    _impl_.config_.dc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MotorConfigAction::unsafe_arena_set_allocated_dc(::hedgehog::protocol::proto::DcConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_config();
  if (value) {
    set_has_dc();
    _impl_.config_.dc_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hedgehog.protocol.proto.MotorConfigAction.dc)
}
inline ::hedgehog::protocol::proto::DcConfig* MotorConfigAction::_internal_mutable_dc() {
  if (config_case() != kDc) {
    clear_config();
    set_has_dc();
    _impl_.config_.dc_ = CreateMaybeMessage<::hedgehog::protocol::proto::DcConfig>(GetArena());
  }
  return _impl_.config_.dc_;
}
inline ::hedgehog::protocol::proto::DcConfig* MotorConfigAction::mutable_dc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hedgehog::protocol::proto::DcConfig* _msg = _internal_mutable_dc();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.MotorConfigAction.dc)
  return _msg;
}

// .hedgehog.protocol.proto.EncoderConfig encoder = 3;
inline bool MotorConfigAction::has_encoder() const {
  return config_case() == kEncoder;
}
inline bool MotorConfigAction::_internal_has_encoder() const {
  return config_case() == kEncoder;
}
inline void MotorConfigAction::set_has_encoder() {
  _impl_._oneof_case_[0] = kEncoder;
}
inline void MotorConfigAction::clear_encoder() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (config_case() == kEncoder) {
    if (GetArena() == nullptr) {
      delete _impl_.config_.encoder_;
    }
    clear_has_config();
  }
}
inline ::hedgehog::protocol::proto::EncoderConfig* MotorConfigAction::release_encoder() {
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.MotorConfigAction.encoder)
  if (config_case() == kEncoder) {
    clear_has_config();
    auto* temp = _impl_.config_.encoder_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.encoder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hedgehog::protocol::proto::EncoderConfig& MotorConfigAction::_internal_encoder() const {
  return config_case() == kEncoder ? *_impl_.config_.encoder_ : reinterpret_cast<::hedgehog::protocol::proto::EncoderConfig&>(::hedgehog::protocol::proto::_EncoderConfig_default_instance_);
}
inline const ::hedgehog::protocol::proto::EncoderConfig& MotorConfigAction::encoder() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorConfigAction.encoder)
  return _internal_encoder();
}
inline ::hedgehog::protocol::proto::EncoderConfig* MotorConfigAction::unsafe_arena_release_encoder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hedgehog.protocol.proto.MotorConfigAction.encoder)
  if (config_case() == kEncoder) {
    clear_has_config();
    auto* temp = _impl_.config_.encoder_;
    _impl_.config_.encoder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MotorConfigAction::unsafe_arena_set_allocated_encoder(::hedgehog::protocol::proto::EncoderConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_config();
  if (value) {
    set_has_encoder();
    _impl_.config_.encoder_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hedgehog.protocol.proto.MotorConfigAction.encoder)
}
inline ::hedgehog::protocol::proto::EncoderConfig* MotorConfigAction::_internal_mutable_encoder() {
  if (config_case() != kEncoder) {
    clear_config();
    set_has_encoder();
    _impl_.config_.encoder_ = CreateMaybeMessage<::hedgehog::protocol::proto::EncoderConfig>(GetArena());
  }
  return _impl_.config_.encoder_;
}
inline ::hedgehog::protocol::proto::EncoderConfig* MotorConfigAction::mutable_encoder() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hedgehog::protocol::proto::EncoderConfig* _msg = _internal_mutable_encoder();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.MotorConfigAction.encoder)
  return _msg;
}

// .hedgehog.protocol.proto.StepperConfig stepper = 4;
inline bool MotorConfigAction::has_stepper() const {
  return config_case() == kStepper;
}
inline bool MotorConfigAction::_internal_has_stepper() const {
  return config_case() == kStepper;
}
inline void MotorConfigAction::set_has_stepper() {
  _impl_._oneof_case_[0] = kStepper;
}
inline void MotorConfigAction::clear_stepper() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (config_case() == kStepper) {
    if (GetArena() == nullptr) {
      delete _impl_.config_.stepper_;
    }
    clear_has_config();
  }
}
inline ::hedgehog::protocol::proto::StepperConfig* MotorConfigAction::release_stepper() {
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.MotorConfigAction.stepper)
  if (config_case() == kStepper) {
    clear_has_config();
    auto* temp = _impl_.config_.stepper_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.stepper_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hedgehog::protocol::proto::StepperConfig& MotorConfigAction::_internal_stepper() const {
  return config_case() == kStepper ? *_impl_.config_.stepper_ : reinterpret_cast<::hedgehog::protocol::proto::StepperConfig&>(::hedgehog::protocol::proto::_StepperConfig_default_instance_);
}
inline const ::hedgehog::protocol::proto::StepperConfig& MotorConfigAction::stepper() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorConfigAction.stepper)
  return _internal_stepper();
}
inline ::hedgehog::protocol::proto::StepperConfig* MotorConfigAction::unsafe_arena_release_stepper() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hedgehog.protocol.proto.MotorConfigAction.stepper)
  if (config_case() == kStepper) {
    clear_has_config();
    auto* temp = _impl_.config_.stepper_;
    _impl_.config_.stepper_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MotorConfigAction::unsafe_arena_set_allocated_stepper(::hedgehog::protocol::proto::StepperConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_config();
  if (value) {
    set_has_stepper();
    _impl_.config_.stepper_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hedgehog.protocol.proto.MotorConfigAction.stepper)
}
inline ::hedgehog::protocol::proto::StepperConfig* MotorConfigAction::_internal_mutable_stepper() {
  if (config_case() != kStepper) {
    clear_config();
    set_has_stepper();
    _impl_.config_.stepper_ = CreateMaybeMessage<::hedgehog::protocol::proto::StepperConfig>(GetArena());
  }
  return _impl_.config_.stepper_;
}
inline ::hedgehog::protocol::proto::StepperConfig* MotorConfigAction::mutable_stepper() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hedgehog::protocol::proto::StepperConfig* _msg = _internal_mutable_stepper();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.MotorConfigAction.stepper)
  return _msg;
}

inline bool MotorConfigAction::has_config() const {
  return config_case() != CONFIG_NOT_SET;
}
inline void MotorConfigAction::clear_has_config() {
  _impl_._oneof_case_[0] = CONFIG_NOT_SET;
}
inline MotorConfigAction::ConfigCase MotorConfigAction::config_case() const {
  return MotorConfigAction::ConfigCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MotorCommandMessage

// uint32 port = 1;
inline void MotorCommandMessage::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0u;
}
inline ::uint32_t MotorCommandMessage::port() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorCommandMessage.port)
  return _internal_port();
}
inline void MotorCommandMessage::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorCommandMessage.port)
}
inline ::uint32_t MotorCommandMessage::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void MotorCommandMessage::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// .hedgehog.protocol.proto.DcConfig dc = 5;
inline bool MotorCommandMessage::has_dc() const {
  return config_case() == kDc;
}
inline bool MotorCommandMessage::_internal_has_dc() const {
  return config_case() == kDc;
}
inline void MotorCommandMessage::set_has_dc() {
  _impl_._oneof_case_[0] = kDc;
}
inline void MotorCommandMessage::clear_dc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (config_case() == kDc) {
    if (GetArena() == nullptr) {
      delete _impl_.config_.dc_;
    }
    clear_has_config();
  }
}
inline ::hedgehog::protocol::proto::DcConfig* MotorCommandMessage::release_dc() {
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.MotorCommandMessage.dc)
  if (config_case() == kDc) {
    clear_has_config();
    auto* temp = _impl_.config_.dc_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.dc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hedgehog::protocol::proto::DcConfig& MotorCommandMessage::_internal_dc() const {
  return config_case() == kDc ? *_impl_.config_.dc_ : reinterpret_cast<::hedgehog::protocol::proto::DcConfig&>(::hedgehog::protocol::proto::_DcConfig_default_instance_);
}
inline const ::hedgehog::protocol::proto::DcConfig& MotorCommandMessage::dc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorCommandMessage.dc)
  return _internal_dc();
}
inline ::hedgehog::protocol::proto::DcConfig* MotorCommandMessage::unsafe_arena_release_dc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hedgehog.protocol.proto.MotorCommandMessage.dc)
  if (config_case() == kDc) {
    clear_has_config();
    auto* temp = _impl_.config_.dc_;
    _impl_.config_.dc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MotorCommandMessage::unsafe_arena_set_allocated_dc(::hedgehog::protocol::proto::DcConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_config();
  if (value) {
    set_has_dc();
    _impl_.config_.dc_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hedgehog.protocol.proto.MotorCommandMessage.dc)
}
inline ::hedgehog::protocol::proto::DcConfig* MotorCommandMessage::_internal_mutable_dc() {
  if (config_case() != kDc) {
    clear_config();
    set_has_dc();
    _impl_.config_.dc_ = CreateMaybeMessage<::hedgehog::protocol::proto::DcConfig>(GetArena());
  }
  return _impl_.config_.dc_;
}
inline ::hedgehog::protocol::proto::DcConfig* MotorCommandMessage::mutable_dc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hedgehog::protocol::proto::DcConfig* _msg = _internal_mutable_dc();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.MotorCommandMessage.dc)
  return _msg;
}

// .hedgehog.protocol.proto.EncoderConfig encoder = 6;
inline bool MotorCommandMessage::has_encoder() const {
  return config_case() == kEncoder;
}
inline bool MotorCommandMessage::_internal_has_encoder() const {
  return config_case() == kEncoder;
}
inline void MotorCommandMessage::set_has_encoder() {
  _impl_._oneof_case_[0] = kEncoder;
}
inline void MotorCommandMessage::clear_encoder() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (config_case() == kEncoder) {
    if (GetArena() == nullptr) {
      delete _impl_.config_.encoder_;
    }
    clear_has_config();
  }
}
inline ::hedgehog::protocol::proto::EncoderConfig* MotorCommandMessage::release_encoder() {
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.MotorCommandMessage.encoder)
  if (config_case() == kEncoder) {
    clear_has_config();
    auto* temp = _impl_.config_.encoder_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.encoder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hedgehog::protocol::proto::EncoderConfig& MotorCommandMessage::_internal_encoder() const {
  return config_case() == kEncoder ? *_impl_.config_.encoder_ : reinterpret_cast<::hedgehog::protocol::proto::EncoderConfig&>(::hedgehog::protocol::proto::_EncoderConfig_default_instance_);
}
inline const ::hedgehog::protocol::proto::EncoderConfig& MotorCommandMessage::encoder() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorCommandMessage.encoder)
  return _internal_encoder();
}
inline ::hedgehog::protocol::proto::EncoderConfig* MotorCommandMessage::unsafe_arena_release_encoder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hedgehog.protocol.proto.MotorCommandMessage.encoder)
  if (config_case() == kEncoder) {
    clear_has_config();
    auto* temp = _impl_.config_.encoder_;
    _impl_.config_.encoder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MotorCommandMessage::unsafe_arena_set_allocated_encoder(::hedgehog::protocol::proto::EncoderConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_config();
  if (value) {
    set_has_encoder();
    _impl_.config_.encoder_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hedgehog.protocol.proto.MotorCommandMessage.encoder)
}
inline ::hedgehog::protocol::proto::EncoderConfig* MotorCommandMessage::_internal_mutable_encoder() {
  if (config_case() != kEncoder) {
    clear_config();
    set_has_encoder();
    _impl_.config_.encoder_ = CreateMaybeMessage<::hedgehog::protocol::proto::EncoderConfig>(GetArena());
  }
  return _impl_.config_.encoder_;
}
inline ::hedgehog::protocol::proto::EncoderConfig* MotorCommandMessage::mutable_encoder() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hedgehog::protocol::proto::EncoderConfig* _msg = _internal_mutable_encoder();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.MotorCommandMessage.encoder)
  return _msg;
}

// .hedgehog.protocol.proto.StepperConfig stepper = 7;
inline bool MotorCommandMessage::has_stepper() const {
  return config_case() == kStepper;
}
inline bool MotorCommandMessage::_internal_has_stepper() const {
  return config_case() == kStepper;
}
inline void MotorCommandMessage::set_has_stepper() {
  _impl_._oneof_case_[0] = kStepper;
}
inline void MotorCommandMessage::clear_stepper() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (config_case() == kStepper) {
    if (GetArena() == nullptr) {
      delete _impl_.config_.stepper_;
    }
    clear_has_config();
  }
}
inline ::hedgehog::protocol::proto::StepperConfig* MotorCommandMessage::release_stepper() {
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.MotorCommandMessage.stepper)
  if (config_case() == kStepper) {
    clear_has_config();
    auto* temp = _impl_.config_.stepper_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.config_.stepper_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hedgehog::protocol::proto::StepperConfig& MotorCommandMessage::_internal_stepper() const {
  return config_case() == kStepper ? *_impl_.config_.stepper_ : reinterpret_cast<::hedgehog::protocol::proto::StepperConfig&>(::hedgehog::protocol::proto::_StepperConfig_default_instance_);
}
inline const ::hedgehog::protocol::proto::StepperConfig& MotorCommandMessage::stepper() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorCommandMessage.stepper)
  return _internal_stepper();
}
inline ::hedgehog::protocol::proto::StepperConfig* MotorCommandMessage::unsafe_arena_release_stepper() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hedgehog.protocol.proto.MotorCommandMessage.stepper)
  if (config_case() == kStepper) {
    clear_has_config();
    auto* temp = _impl_.config_.stepper_;
    _impl_.config_.stepper_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MotorCommandMessage::unsafe_arena_set_allocated_stepper(::hedgehog::protocol::proto::StepperConfig* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_config();
  if (value) {
    set_has_stepper();
    _impl_.config_.stepper_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hedgehog.protocol.proto.MotorCommandMessage.stepper)
}
inline ::hedgehog::protocol::proto::StepperConfig* MotorCommandMessage::_internal_mutable_stepper() {
  if (config_case() != kStepper) {
    clear_config();
    set_has_stepper();
    _impl_.config_.stepper_ = CreateMaybeMessage<::hedgehog::protocol::proto::StepperConfig>(GetArena());
  }
  return _impl_.config_.stepper_;
}
inline ::hedgehog::protocol::proto::StepperConfig* MotorCommandMessage::mutable_stepper() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hedgehog::protocol::proto::StepperConfig* _msg = _internal_mutable_stepper();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.MotorCommandMessage.stepper)
  return _msg;
}

// .hedgehog.protocol.proto.MotorState state = 2;
inline void MotorCommandMessage::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
}
inline ::hedgehog::protocol::proto::MotorState MotorCommandMessage::state() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorCommandMessage.state)
  return _internal_state();
}
inline void MotorCommandMessage::set_state(::hedgehog::protocol::proto::MotorState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorCommandMessage.state)
}
inline ::hedgehog::protocol::proto::MotorState MotorCommandMessage::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::hedgehog::protocol::proto::MotorState>(_impl_.state_);
}
inline void MotorCommandMessage::_internal_set_state(::hedgehog::protocol::proto::MotorState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// sint32 amount = 3;
inline void MotorCommandMessage::clear_amount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.amount_ = 0;
}
inline ::int32_t MotorCommandMessage::amount() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorCommandMessage.amount)
  return _internal_amount();
}
inline void MotorCommandMessage::set_amount(::int32_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorCommandMessage.amount)
}
inline ::int32_t MotorCommandMessage::_internal_amount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.amount_;
}
inline void MotorCommandMessage::_internal_set_amount(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.amount_ = value;
}

// .hedgehog.protocol.proto.Subscription subscription = 4;
inline bool MotorCommandMessage::has_subscription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subscription_ != nullptr);
  return value;
}
inline const ::hedgehog::protocol::proto::Subscription& MotorCommandMessage::_internal_subscription() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hedgehog::protocol::proto::Subscription* p = _impl_.subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::hedgehog::protocol::proto::Subscription&>(::hedgehog::protocol::proto::_Subscription_default_instance_);
}
inline const ::hedgehog::protocol::proto::Subscription& MotorCommandMessage::subscription() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorCommandMessage.subscription)
  return _internal_subscription();
}
inline void MotorCommandMessage::unsafe_arena_set_allocated_subscription(::hedgehog::protocol::proto::Subscription* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.subscription_);
  }
  _impl_.subscription_ = reinterpret_cast<::hedgehog::protocol::proto::Subscription*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hedgehog.protocol.proto.MotorCommandMessage.subscription)
}
inline ::hedgehog::protocol::proto::Subscription* MotorCommandMessage::release_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hedgehog::protocol::proto::Subscription* released = _impl_.subscription_;
  _impl_.subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hedgehog::protocol::proto::Subscription* MotorCommandMessage::unsafe_arena_release_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.MotorCommandMessage.subscription)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hedgehog::protocol::proto::Subscription* temp = _impl_.subscription_;
  _impl_.subscription_ = nullptr;
  return temp;
}
inline ::hedgehog::protocol::proto::Subscription* MotorCommandMessage::_internal_mutable_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::hedgehog::protocol::proto::Subscription>(GetArena());
    _impl_.subscription_ = reinterpret_cast<::hedgehog::protocol::proto::Subscription*>(p);
  }
  return _impl_.subscription_;
}
inline ::hedgehog::protocol::proto::Subscription* MotorCommandMessage::mutable_subscription() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hedgehog::protocol::proto::Subscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.MotorCommandMessage.subscription)
  return _msg;
}
inline void MotorCommandMessage::set_allocated_subscription(::hedgehog::protocol::proto::Subscription* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.subscription_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.subscription_ = reinterpret_cast<::hedgehog::protocol::proto::Subscription*>(value);
  // @@protoc_insertion_point(field_set_allocated:hedgehog.protocol.proto.MotorCommandMessage.subscription)
}

inline bool MotorCommandMessage::has_config() const {
  return config_case() != CONFIG_NOT_SET;
}
inline void MotorCommandMessage::clear_has_config() {
  _impl_._oneof_case_[0] = CONFIG_NOT_SET;
}
inline MotorCommandMessage::ConfigCase MotorCommandMessage::config_case() const {
  return MotorCommandMessage::ConfigCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MotorStateMessage

// uint32 port = 1;
inline void MotorStateMessage::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0u;
}
inline ::uint32_t MotorStateMessage::port() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorStateMessage.port)
  return _internal_port();
}
inline void MotorStateMessage::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorStateMessage.port)
}
inline ::uint32_t MotorStateMessage::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void MotorStateMessage::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// sint32 velocity = 2;
inline void MotorStateMessage::clear_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.velocity_ = 0;
}
inline ::int32_t MotorStateMessage::velocity() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorStateMessage.velocity)
  return _internal_velocity();
}
inline void MotorStateMessage::set_velocity(::int32_t value) {
  _internal_set_velocity(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorStateMessage.velocity)
}
inline ::int32_t MotorStateMessage::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.velocity_;
}
inline void MotorStateMessage::_internal_set_velocity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.velocity_ = value;
}

// sint32 position = 3;
inline void MotorStateMessage::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.position_ = 0;
}
inline ::int32_t MotorStateMessage::position() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorStateMessage.position)
  return _internal_position();
}
inline void MotorStateMessage::set_position(::int32_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorStateMessage.position)
}
inline ::int32_t MotorStateMessage::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.position_;
}
inline void MotorStateMessage::_internal_set_position(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.position_ = value;
}

// .hedgehog.protocol.proto.Subscription subscription = 4;
inline bool MotorStateMessage::has_subscription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subscription_ != nullptr);
  return value;
}
inline const ::hedgehog::protocol::proto::Subscription& MotorStateMessage::_internal_subscription() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hedgehog::protocol::proto::Subscription* p = _impl_.subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::hedgehog::protocol::proto::Subscription&>(::hedgehog::protocol::proto::_Subscription_default_instance_);
}
inline const ::hedgehog::protocol::proto::Subscription& MotorStateMessage::subscription() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorStateMessage.subscription)
  return _internal_subscription();
}
inline void MotorStateMessage::unsafe_arena_set_allocated_subscription(::hedgehog::protocol::proto::Subscription* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.subscription_);
  }
  _impl_.subscription_ = reinterpret_cast<::hedgehog::protocol::proto::Subscription*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hedgehog.protocol.proto.MotorStateMessage.subscription)
}
inline ::hedgehog::protocol::proto::Subscription* MotorStateMessage::release_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hedgehog::protocol::proto::Subscription* released = _impl_.subscription_;
  _impl_.subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hedgehog::protocol::proto::Subscription* MotorStateMessage::unsafe_arena_release_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.MotorStateMessage.subscription)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hedgehog::protocol::proto::Subscription* temp = _impl_.subscription_;
  _impl_.subscription_ = nullptr;
  return temp;
}
inline ::hedgehog::protocol::proto::Subscription* MotorStateMessage::_internal_mutable_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::hedgehog::protocol::proto::Subscription>(GetArena());
    _impl_.subscription_ = reinterpret_cast<::hedgehog::protocol::proto::Subscription*>(p);
  }
  return _impl_.subscription_;
}
inline ::hedgehog::protocol::proto::Subscription* MotorStateMessage::mutable_subscription() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hedgehog::protocol::proto::Subscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.MotorStateMessage.subscription)
  return _msg;
}
inline void MotorStateMessage::set_allocated_subscription(::hedgehog::protocol::proto::Subscription* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.subscription_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.subscription_ = reinterpret_cast<::hedgehog::protocol::proto::Subscription*>(value);
  // @@protoc_insertion_point(field_set_allocated:hedgehog.protocol.proto.MotorStateMessage.subscription)
}

// -------------------------------------------------------------------

// MotorSetPositionAction

// uint32 port = 1;
inline void MotorSetPositionAction::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0u;
}
inline ::uint32_t MotorSetPositionAction::port() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorSetPositionAction.port)
  return _internal_port();
}
inline void MotorSetPositionAction::set_port(::uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorSetPositionAction.port)
}
inline ::uint32_t MotorSetPositionAction::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void MotorSetPositionAction::_internal_set_port(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.port_ = value;
}

// sint32 position = 2;
inline void MotorSetPositionAction::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.position_ = 0;
}
inline ::int32_t MotorSetPositionAction::position() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.MotorSetPositionAction.position)
  return _internal_position();
}
inline void MotorSetPositionAction::set_position(::int32_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.MotorSetPositionAction.position)
}
inline ::int32_t MotorSetPositionAction::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.position_;
}
inline void MotorSetPositionAction::_internal_set_position(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.position_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace protocol
}  // namespace hedgehog


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::hedgehog::protocol::proto::MotorState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::hedgehog::protocol::proto::MotorState>() {
  return ::hedgehog::protocol::proto::MotorState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_hedgehog_2fprotocol_2fproto_2fmotor_2eproto_2epb_2eh
