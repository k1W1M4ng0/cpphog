// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hedgehog/protocol/proto/vision.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_hedgehog_2fprotocol_2fproto_2fvision_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_hedgehog_2fprotocol_2fproto_2fvision_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_hedgehog_2fprotocol_2fproto_2fvision_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
namespace hedgehog {
namespace protocol {
namespace proto {
class Blob;
struct BlobDefaultTypeInternal;
extern BlobDefaultTypeInternal _Blob_default_instance_;
class BlobsChannel;
struct BlobsChannelDefaultTypeInternal;
extern BlobsChannelDefaultTypeInternal _BlobsChannel_default_instance_;
class BlobsFeature;
struct BlobsFeatureDefaultTypeInternal;
extern BlobsFeatureDefaultTypeInternal _BlobsFeature_default_instance_;
class Channel;
struct ChannelDefaultTypeInternal;
extern ChannelDefaultTypeInternal _Channel_default_instance_;
class Face;
struct FaceDefaultTypeInternal;
extern FaceDefaultTypeInternal _Face_default_instance_;
class FacesChannel;
struct FacesChannelDefaultTypeInternal;
extern FacesChannelDefaultTypeInternal _FacesChannel_default_instance_;
class FacesFeature;
struct FacesFeatureDefaultTypeInternal;
extern FacesFeatureDefaultTypeInternal _FacesFeature_default_instance_;
class Feature;
struct FeatureDefaultTypeInternal;
extern FeatureDefaultTypeInternal _Feature_default_instance_;
class VisionCameraAction;
struct VisionCameraActionDefaultTypeInternal;
extern VisionCameraActionDefaultTypeInternal _VisionCameraAction_default_instance_;
class VisionCaptureFrameAction;
struct VisionCaptureFrameActionDefaultTypeInternal;
extern VisionCaptureFrameActionDefaultTypeInternal _VisionCaptureFrameAction_default_instance_;
class VisionChannelMessage;
struct VisionChannelMessageDefaultTypeInternal;
extern VisionChannelMessageDefaultTypeInternal _VisionChannelMessage_default_instance_;
class VisionFeatureMessage;
struct VisionFeatureMessageDefaultTypeInternal;
extern VisionFeatureMessageDefaultTypeInternal _VisionFeatureMessage_default_instance_;
class VisionFrameMessage;
struct VisionFrameMessageDefaultTypeInternal;
extern VisionFrameMessageDefaultTypeInternal _VisionFrameMessage_default_instance_;
}  // namespace proto
}  // namespace protocol
}  // namespace hedgehog
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace hedgehog {
namespace protocol {
namespace proto {
enum ChannelOperation : int {
  READ = 0,
  CREATE = 1,
  UPDATE = 2,
  DELETE = 3,
  ChannelOperation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChannelOperation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChannelOperation_IsValid(int value);
extern const uint32_t ChannelOperation_internal_data_[];
constexpr ChannelOperation ChannelOperation_MIN = static_cast<ChannelOperation>(0);
constexpr ChannelOperation ChannelOperation_MAX = static_cast<ChannelOperation>(3);
constexpr int ChannelOperation_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ChannelOperation_descriptor();
template <typename T>
const std::string& ChannelOperation_Name(T value) {
  static_assert(std::is_same<T, ChannelOperation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ChannelOperation_Name().");
  return ChannelOperation_Name(static_cast<ChannelOperation>(value));
}
template <>
inline const std::string& ChannelOperation_Name(ChannelOperation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChannelOperation_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ChannelOperation_Parse(absl::string_view name, ChannelOperation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChannelOperation>(
      ChannelOperation_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VisionFrameMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.VisionFrameMessage) */ {
 public:
  inline VisionFrameMessage() : VisionFrameMessage(nullptr) {}
  ~VisionFrameMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VisionFrameMessage(::google::protobuf::internal::ConstantInitialized);

  inline VisionFrameMessage(const VisionFrameMessage& from)
      : VisionFrameMessage(nullptr, from) {}
  VisionFrameMessage(VisionFrameMessage&& from) noexcept
    : VisionFrameMessage() {
    *this = ::std::move(from);
  }

  inline VisionFrameMessage& operator=(const VisionFrameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionFrameMessage& operator=(VisionFrameMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionFrameMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionFrameMessage* internal_default_instance() {
    return reinterpret_cast<const VisionFrameMessage*>(
               &_VisionFrameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VisionFrameMessage& a, VisionFrameMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionFrameMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionFrameMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionFrameMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionFrameMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisionFrameMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VisionFrameMessage& from) {
    VisionFrameMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VisionFrameMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.VisionFrameMessage";
  }
  protected:
  explicit VisionFrameMessage(::google::protobuf::Arena* arena);
  VisionFrameMessage(::google::protobuf::Arena* arena, const VisionFrameMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHighlightFieldNumber = 1,
    kFrameFieldNumber = 2,
  };
  // string highlight = 1;
  void clear_highlight() ;
  const std::string& highlight() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_highlight(Arg_&& arg, Args_... args);
  std::string* mutable_highlight();
  PROTOBUF_NODISCARD std::string* release_highlight();
  void set_allocated_highlight(std::string* value);

  private:
  const std::string& _internal_highlight() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_highlight(
      const std::string& value);
  std::string* _internal_mutable_highlight();

  public:
  // bytes frame = 2;
  void clear_frame() ;
  const std::string& frame() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_frame(Arg_&& arg, Args_... args);
  std::string* mutable_frame();
  PROTOBUF_NODISCARD std::string* release_frame();
  void set_allocated_frame(std::string* value);

  private:
  const std::string& _internal_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame(
      const std::string& value);
  std::string* _internal_mutable_frame();

  public:
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.VisionFrameMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr highlight_;
    ::google::protobuf::internal::ArenaStringPtr frame_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
};// -------------------------------------------------------------------

class VisionCaptureFrameAction final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.VisionCaptureFrameAction) */ {
 public:
  inline VisionCaptureFrameAction() : VisionCaptureFrameAction(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VisionCaptureFrameAction(::google::protobuf::internal::ConstantInitialized);

  inline VisionCaptureFrameAction(const VisionCaptureFrameAction& from)
      : VisionCaptureFrameAction(nullptr, from) {}
  VisionCaptureFrameAction(VisionCaptureFrameAction&& from) noexcept
    : VisionCaptureFrameAction() {
    *this = ::std::move(from);
  }

  inline VisionCaptureFrameAction& operator=(const VisionCaptureFrameAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionCaptureFrameAction& operator=(VisionCaptureFrameAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionCaptureFrameAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionCaptureFrameAction* internal_default_instance() {
    return reinterpret_cast<const VisionCaptureFrameAction*>(
               &_VisionCaptureFrameAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VisionCaptureFrameAction& a, VisionCaptureFrameAction& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionCaptureFrameAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionCaptureFrameAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionCaptureFrameAction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionCaptureFrameAction>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const VisionCaptureFrameAction& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const VisionCaptureFrameAction& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.VisionCaptureFrameAction";
  }
  protected:
  explicit VisionCaptureFrameAction(::google::protobuf::Arena* arena);
  VisionCaptureFrameAction(::google::protobuf::Arena* arena, const VisionCaptureFrameAction& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.VisionCaptureFrameAction)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
};// -------------------------------------------------------------------

class VisionCameraAction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.VisionCameraAction) */ {
 public:
  inline VisionCameraAction() : VisionCameraAction(nullptr) {}
  ~VisionCameraAction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VisionCameraAction(::google::protobuf::internal::ConstantInitialized);

  inline VisionCameraAction(const VisionCameraAction& from)
      : VisionCameraAction(nullptr, from) {}
  VisionCameraAction(VisionCameraAction&& from) noexcept
    : VisionCameraAction() {
    *this = ::std::move(from);
  }

  inline VisionCameraAction& operator=(const VisionCameraAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionCameraAction& operator=(VisionCameraAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionCameraAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionCameraAction* internal_default_instance() {
    return reinterpret_cast<const VisionCameraAction*>(
               &_VisionCameraAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(VisionCameraAction& a, VisionCameraAction& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionCameraAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionCameraAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionCameraAction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionCameraAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisionCameraAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VisionCameraAction& from) {
    VisionCameraAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VisionCameraAction* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.VisionCameraAction";
  }
  protected:
  explicit VisionCameraAction(::google::protobuf::Arena* arena);
  VisionCameraAction(::google::protobuf::Arena* arena, const VisionCameraAction& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpenFieldNumber = 1,
  };
  // bool open = 1;
  void clear_open() ;
  bool open() const;
  void set_open(bool value);

  private:
  bool _internal_open() const;
  void _internal_set_open(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.VisionCameraAction)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool open_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
};// -------------------------------------------------------------------

class FacesChannel final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.FacesChannel) */ {
 public:
  inline FacesChannel() : FacesChannel(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FacesChannel(::google::protobuf::internal::ConstantInitialized);

  inline FacesChannel(const FacesChannel& from)
      : FacesChannel(nullptr, from) {}
  FacesChannel(FacesChannel&& from) noexcept
    : FacesChannel() {
    *this = ::std::move(from);
  }

  inline FacesChannel& operator=(const FacesChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline FacesChannel& operator=(FacesChannel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FacesChannel& default_instance() {
    return *internal_default_instance();
  }
  static inline const FacesChannel* internal_default_instance() {
    return reinterpret_cast<const FacesChannel*>(
               &_FacesChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FacesChannel& a, FacesChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(FacesChannel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FacesChannel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FacesChannel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FacesChannel>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FacesChannel& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FacesChannel& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.FacesChannel";
  }
  protected:
  explicit FacesChannel(::google::protobuf::Arena* arena);
  FacesChannel(::google::protobuf::Arena* arena, const FacesChannel& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.FacesChannel)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
};// -------------------------------------------------------------------

class Face final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.Face) */ {
 public:
  inline Face() : Face(nullptr) {}
  ~Face() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Face(::google::protobuf::internal::ConstantInitialized);

  inline Face(const Face& from)
      : Face(nullptr, from) {}
  Face(Face&& from) noexcept
    : Face() {
    *this = ::std::move(from);
  }

  inline Face& operator=(const Face& from) {
    CopyFrom(from);
    return *this;
  }
  inline Face& operator=(Face&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Face& default_instance() {
    return *internal_default_instance();
  }
  static inline const Face* internal_default_instance() {
    return reinterpret_cast<const Face*>(
               &_Face_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Face& a, Face& b) {
    a.Swap(&b);
  }
  inline void Swap(Face* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Face* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Face* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Face>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Face& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Face& from) {
    Face::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Face* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.Face";
  }
  protected:
  explicit Face(::google::protobuf::Arena* arena);
  Face(::google::protobuf::Arena* arena, const Face& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // int32 width = 3;
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // int32 height = 4;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.Face)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t x_;
    ::int32_t y_;
    ::int32_t width_;
    ::int32_t height_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
};// -------------------------------------------------------------------

class BlobsChannel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.BlobsChannel) */ {
 public:
  inline BlobsChannel() : BlobsChannel(nullptr) {}
  ~BlobsChannel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlobsChannel(::google::protobuf::internal::ConstantInitialized);

  inline BlobsChannel(const BlobsChannel& from)
      : BlobsChannel(nullptr, from) {}
  BlobsChannel(BlobsChannel&& from) noexcept
    : BlobsChannel() {
    *this = ::std::move(from);
  }

  inline BlobsChannel& operator=(const BlobsChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlobsChannel& operator=(BlobsChannel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlobsChannel& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlobsChannel* internal_default_instance() {
    return reinterpret_cast<const BlobsChannel*>(
               &_BlobsChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BlobsChannel& a, BlobsChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(BlobsChannel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlobsChannel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlobsChannel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlobsChannel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlobsChannel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BlobsChannel& from) {
    BlobsChannel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BlobsChannel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.BlobsChannel";
  }
  protected:
  explicit BlobsChannel(::google::protobuf::Arena* arena);
  BlobsChannel(::google::protobuf::Arena* arena, const BlobsChannel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHsvMinFieldNumber = 1,
    kHsvMaxFieldNumber = 2,
  };
  // fixed32 hsv_min = 1;
  void clear_hsv_min() ;
  ::uint32_t hsv_min() const;
  void set_hsv_min(::uint32_t value);

  private:
  ::uint32_t _internal_hsv_min() const;
  void _internal_set_hsv_min(::uint32_t value);

  public:
  // fixed32 hsv_max = 2;
  void clear_hsv_max() ;
  ::uint32_t hsv_max() const;
  void set_hsv_max(::uint32_t value);

  private:
  ::uint32_t _internal_hsv_max() const;
  void _internal_set_hsv_max(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.BlobsChannel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t hsv_min_;
    ::uint32_t hsv_max_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
};// -------------------------------------------------------------------

class Blob final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.Blob) */ {
 public:
  inline Blob() : Blob(nullptr) {}
  ~Blob() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Blob(::google::protobuf::internal::ConstantInitialized);

  inline Blob(const Blob& from)
      : Blob(nullptr, from) {}
  Blob(Blob&& from) noexcept
    : Blob() {
    *this = ::std::move(from);
  }

  inline Blob& operator=(const Blob& from) {
    CopyFrom(from);
    return *this;
  }
  inline Blob& operator=(Blob&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Blob& default_instance() {
    return *internal_default_instance();
  }
  static inline const Blob* internal_default_instance() {
    return reinterpret_cast<const Blob*>(
               &_Blob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Blob& a, Blob& b) {
    a.Swap(&b);
  }
  inline void Swap(Blob* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Blob* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Blob* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Blob>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Blob& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Blob& from) {
    Blob::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Blob* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.Blob";
  }
  protected:
  explicit Blob(::google::protobuf::Arena* arena);
  Blob(::google::protobuf::Arena* arena, const Blob& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kCxFieldNumber = 5,
    kCyFieldNumber = 6,
    kConfidenceFieldNumber = 7,
  };
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // int32 width = 3;
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // int32 height = 4;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // int32 cx = 5;
  void clear_cx() ;
  ::int32_t cx() const;
  void set_cx(::int32_t value);

  private:
  ::int32_t _internal_cx() const;
  void _internal_set_cx(::int32_t value);

  public:
  // int32 cy = 6;
  void clear_cy() ;
  ::int32_t cy() const;
  void set_cy(::int32_t value);

  private:
  ::int32_t _internal_cy() const;
  void _internal_set_cy(::int32_t value);

  public:
  // float confidence = 7;
  void clear_confidence() ;
  float confidence() const;
  void set_confidence(float value);

  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);

  public:
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.Blob)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t x_;
    ::int32_t y_;
    ::int32_t width_;
    ::int32_t height_;
    ::int32_t cx_;
    ::int32_t cy_;
    float confidence_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
};// -------------------------------------------------------------------

class FacesFeature final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.FacesFeature) */ {
 public:
  inline FacesFeature() : FacesFeature(nullptr) {}
  ~FacesFeature() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FacesFeature(::google::protobuf::internal::ConstantInitialized);

  inline FacesFeature(const FacesFeature& from)
      : FacesFeature(nullptr, from) {}
  FacesFeature(FacesFeature&& from) noexcept
    : FacesFeature() {
    *this = ::std::move(from);
  }

  inline FacesFeature& operator=(const FacesFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline FacesFeature& operator=(FacesFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FacesFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const FacesFeature* internal_default_instance() {
    return reinterpret_cast<const FacesFeature*>(
               &_FacesFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FacesFeature& a, FacesFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(FacesFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FacesFeature* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FacesFeature* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FacesFeature>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FacesFeature& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FacesFeature& from) {
    FacesFeature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FacesFeature* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.FacesFeature";
  }
  protected:
  explicit FacesFeature(::google::protobuf::Arena* arena);
  FacesFeature(::google::protobuf::Arena* arena, const FacesFeature& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFacesFieldNumber = 1,
  };
  // repeated .hedgehog.protocol.proto.Face faces = 1;
  int faces_size() const;
  private:
  int _internal_faces_size() const;

  public:
  void clear_faces() ;
  ::hedgehog::protocol::proto::Face* mutable_faces(int index);
  ::google::protobuf::RepeatedPtrField< ::hedgehog::protocol::proto::Face >*
      mutable_faces();
  private:
  const ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Face>& _internal_faces() const;
  ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Face>* _internal_mutable_faces();
  public:
  const ::hedgehog::protocol::proto::Face& faces(int index) const;
  ::hedgehog::protocol::proto::Face* add_faces();
  const ::google::protobuf::RepeatedPtrField< ::hedgehog::protocol::proto::Face >&
      faces() const;
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.FacesFeature)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::hedgehog::protocol::proto::Face > faces_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
};// -------------------------------------------------------------------

class Channel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.Channel) */ {
 public:
  inline Channel() : Channel(nullptr) {}
  ~Channel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Channel(::google::protobuf::internal::ConstantInitialized);

  inline Channel(const Channel& from)
      : Channel(nullptr, from) {}
  Channel(Channel&& from) noexcept
    : Channel() {
    *this = ::std::move(from);
  }

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Channel& operator=(Channel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Channel& default_instance() {
    return *internal_default_instance();
  }
  enum ChannelCase {
    kFaces = 2,
    kBlobs = 3,
    CHANNEL_NOT_SET = 0,
  };

  static inline const Channel* internal_default_instance() {
    return reinterpret_cast<const Channel*>(
               &_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Channel& a, Channel& b) {
    a.Swap(&b);
  }
  inline void Swap(Channel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Channel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Channel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Channel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Channel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Channel& from) {
    Channel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Channel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.Channel";
  }
  protected:
  explicit Channel(::google::protobuf::Arena* arena);
  Channel(::google::protobuf::Arena* arena, const Channel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kFacesFieldNumber = 2,
    kBlobsFieldNumber = 3,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // .hedgehog.protocol.proto.FacesChannel faces = 2;
  bool has_faces() const;
  private:
  bool _internal_has_faces() const;

  public:
  void clear_faces() ;
  const ::hedgehog::protocol::proto::FacesChannel& faces() const;
  PROTOBUF_NODISCARD ::hedgehog::protocol::proto::FacesChannel* release_faces();
  ::hedgehog::protocol::proto::FacesChannel* mutable_faces();
  void set_allocated_faces(::hedgehog::protocol::proto::FacesChannel* value);
  void unsafe_arena_set_allocated_faces(::hedgehog::protocol::proto::FacesChannel* value);
  ::hedgehog::protocol::proto::FacesChannel* unsafe_arena_release_faces();

  private:
  const ::hedgehog::protocol::proto::FacesChannel& _internal_faces() const;
  ::hedgehog::protocol::proto::FacesChannel* _internal_mutable_faces();

  public:
  // .hedgehog.protocol.proto.BlobsChannel blobs = 3;
  bool has_blobs() const;
  private:
  bool _internal_has_blobs() const;

  public:
  void clear_blobs() ;
  const ::hedgehog::protocol::proto::BlobsChannel& blobs() const;
  PROTOBUF_NODISCARD ::hedgehog::protocol::proto::BlobsChannel* release_blobs();
  ::hedgehog::protocol::proto::BlobsChannel* mutable_blobs();
  void set_allocated_blobs(::hedgehog::protocol::proto::BlobsChannel* value);
  void unsafe_arena_set_allocated_blobs(::hedgehog::protocol::proto::BlobsChannel* value);
  ::hedgehog::protocol::proto::BlobsChannel* unsafe_arena_release_blobs();

  private:
  const ::hedgehog::protocol::proto::BlobsChannel& _internal_blobs() const;
  ::hedgehog::protocol::proto::BlobsChannel* _internal_mutable_blobs();

  public:
  void clear_channel();
  ChannelCase channel_case() const;
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.Channel)
 private:
  class _Internal;
  void set_has_faces();
  void set_has_blobs();

  inline bool has_channel() const;
  inline void clear_has_channel();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 2,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr key_;
    union ChannelUnion {
      constexpr ChannelUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::hedgehog::protocol::proto::FacesChannel* faces_;
      ::hedgehog::protocol::proto::BlobsChannel* blobs_;
    } channel_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
};// -------------------------------------------------------------------

class BlobsFeature final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.BlobsFeature) */ {
 public:
  inline BlobsFeature() : BlobsFeature(nullptr) {}
  ~BlobsFeature() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlobsFeature(::google::protobuf::internal::ConstantInitialized);

  inline BlobsFeature(const BlobsFeature& from)
      : BlobsFeature(nullptr, from) {}
  BlobsFeature(BlobsFeature&& from) noexcept
    : BlobsFeature() {
    *this = ::std::move(from);
  }

  inline BlobsFeature& operator=(const BlobsFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlobsFeature& operator=(BlobsFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlobsFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlobsFeature* internal_default_instance() {
    return reinterpret_cast<const BlobsFeature*>(
               &_BlobsFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BlobsFeature& a, BlobsFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(BlobsFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlobsFeature* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlobsFeature* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlobsFeature>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlobsFeature& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BlobsFeature& from) {
    BlobsFeature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BlobsFeature* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.BlobsFeature";
  }
  protected:
  explicit BlobsFeature(::google::protobuf::Arena* arena);
  BlobsFeature(::google::protobuf::Arena* arena, const BlobsFeature& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobsFieldNumber = 1,
  };
  // repeated .hedgehog.protocol.proto.Blob blobs = 1;
  int blobs_size() const;
  private:
  int _internal_blobs_size() const;

  public:
  void clear_blobs() ;
  ::hedgehog::protocol::proto::Blob* mutable_blobs(int index);
  ::google::protobuf::RepeatedPtrField< ::hedgehog::protocol::proto::Blob >*
      mutable_blobs();
  private:
  const ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Blob>& _internal_blobs() const;
  ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Blob>* _internal_mutable_blobs();
  public:
  const ::hedgehog::protocol::proto::Blob& blobs(int index) const;
  ::hedgehog::protocol::proto::Blob* add_blobs();
  const ::google::protobuf::RepeatedPtrField< ::hedgehog::protocol::proto::Blob >&
      blobs() const;
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.BlobsFeature)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::hedgehog::protocol::proto::Blob > blobs_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
};// -------------------------------------------------------------------

class VisionChannelMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.VisionChannelMessage) */ {
 public:
  inline VisionChannelMessage() : VisionChannelMessage(nullptr) {}
  ~VisionChannelMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VisionChannelMessage(::google::protobuf::internal::ConstantInitialized);

  inline VisionChannelMessage(const VisionChannelMessage& from)
      : VisionChannelMessage(nullptr, from) {}
  VisionChannelMessage(VisionChannelMessage&& from) noexcept
    : VisionChannelMessage() {
    *this = ::std::move(from);
  }

  inline VisionChannelMessage& operator=(const VisionChannelMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionChannelMessage& operator=(VisionChannelMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionChannelMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionChannelMessage* internal_default_instance() {
    return reinterpret_cast<const VisionChannelMessage*>(
               &_VisionChannelMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VisionChannelMessage& a, VisionChannelMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionChannelMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionChannelMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionChannelMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionChannelMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisionChannelMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VisionChannelMessage& from) {
    VisionChannelMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VisionChannelMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.VisionChannelMessage";
  }
  protected:
  explicit VisionChannelMessage(::google::protobuf::Arena* arena);
  VisionChannelMessage(::google::protobuf::Arena* arena, const VisionChannelMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 2,
    kOpFieldNumber = 1,
  };
  // repeated .hedgehog.protocol.proto.Channel channels = 2;
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::hedgehog::protocol::proto::Channel* mutable_channels(int index);
  ::google::protobuf::RepeatedPtrField< ::hedgehog::protocol::proto::Channel >*
      mutable_channels();
  private:
  const ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Channel>& _internal_channels() const;
  ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Channel>* _internal_mutable_channels();
  public:
  const ::hedgehog::protocol::proto::Channel& channels(int index) const;
  ::hedgehog::protocol::proto::Channel* add_channels();
  const ::google::protobuf::RepeatedPtrField< ::hedgehog::protocol::proto::Channel >&
      channels() const;
  // .hedgehog.protocol.proto.ChannelOperation op = 1;
  void clear_op() ;
  ::hedgehog::protocol::proto::ChannelOperation op() const;
  void set_op(::hedgehog::protocol::proto::ChannelOperation value);

  private:
  ::hedgehog::protocol::proto::ChannelOperation _internal_op() const;
  void _internal_set_op(::hedgehog::protocol::proto::ChannelOperation value);

  public:
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.VisionChannelMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::hedgehog::protocol::proto::Channel > channels_;
    int op_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
};// -------------------------------------------------------------------

class Feature final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.Feature) */ {
 public:
  inline Feature() : Feature(nullptr) {}
  ~Feature() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Feature(::google::protobuf::internal::ConstantInitialized);

  inline Feature(const Feature& from)
      : Feature(nullptr, from) {}
  Feature(Feature&& from) noexcept
    : Feature() {
    *this = ::std::move(from);
  }

  inline Feature& operator=(const Feature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Feature& operator=(Feature&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Feature& default_instance() {
    return *internal_default_instance();
  }
  enum FeatureCase {
    kFaces = 1,
    kBlobs = 2,
    FEATURE_NOT_SET = 0,
  };

  static inline const Feature* internal_default_instance() {
    return reinterpret_cast<const Feature*>(
               &_Feature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Feature& a, Feature& b) {
    a.Swap(&b);
  }
  inline void Swap(Feature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Feature* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Feature* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Feature>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Feature& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Feature& from) {
    Feature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Feature* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.Feature";
  }
  protected:
  explicit Feature(::google::protobuf::Arena* arena);
  Feature(::google::protobuf::Arena* arena, const Feature& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFacesFieldNumber = 1,
    kBlobsFieldNumber = 2,
  };
  // .hedgehog.protocol.proto.FacesFeature faces = 1;
  bool has_faces() const;
  private:
  bool _internal_has_faces() const;

  public:
  void clear_faces() ;
  const ::hedgehog::protocol::proto::FacesFeature& faces() const;
  PROTOBUF_NODISCARD ::hedgehog::protocol::proto::FacesFeature* release_faces();
  ::hedgehog::protocol::proto::FacesFeature* mutable_faces();
  void set_allocated_faces(::hedgehog::protocol::proto::FacesFeature* value);
  void unsafe_arena_set_allocated_faces(::hedgehog::protocol::proto::FacesFeature* value);
  ::hedgehog::protocol::proto::FacesFeature* unsafe_arena_release_faces();

  private:
  const ::hedgehog::protocol::proto::FacesFeature& _internal_faces() const;
  ::hedgehog::protocol::proto::FacesFeature* _internal_mutable_faces();

  public:
  // .hedgehog.protocol.proto.BlobsFeature blobs = 2;
  bool has_blobs() const;
  private:
  bool _internal_has_blobs() const;

  public:
  void clear_blobs() ;
  const ::hedgehog::protocol::proto::BlobsFeature& blobs() const;
  PROTOBUF_NODISCARD ::hedgehog::protocol::proto::BlobsFeature* release_blobs();
  ::hedgehog::protocol::proto::BlobsFeature* mutable_blobs();
  void set_allocated_blobs(::hedgehog::protocol::proto::BlobsFeature* value);
  void unsafe_arena_set_allocated_blobs(::hedgehog::protocol::proto::BlobsFeature* value);
  ::hedgehog::protocol::proto::BlobsFeature* unsafe_arena_release_blobs();

  private:
  const ::hedgehog::protocol::proto::BlobsFeature& _internal_blobs() const;
  ::hedgehog::protocol::proto::BlobsFeature* _internal_mutable_blobs();

  public:
  void clear_feature();
  FeatureCase feature_case() const;
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.Feature)
 private:
  class _Internal;
  void set_has_faces();
  void set_has_blobs();

  inline bool has_feature() const;
  inline void clear_has_feature();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union FeatureUnion {
      constexpr FeatureUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::hedgehog::protocol::proto::FacesFeature* faces_;
      ::hedgehog::protocol::proto::BlobsFeature* blobs_;
    } feature_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
};// -------------------------------------------------------------------

class VisionFeatureMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hedgehog.protocol.proto.VisionFeatureMessage) */ {
 public:
  inline VisionFeatureMessage() : VisionFeatureMessage(nullptr) {}
  ~VisionFeatureMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VisionFeatureMessage(::google::protobuf::internal::ConstantInitialized);

  inline VisionFeatureMessage(const VisionFeatureMessage& from)
      : VisionFeatureMessage(nullptr, from) {}
  VisionFeatureMessage(VisionFeatureMessage&& from) noexcept
    : VisionFeatureMessage() {
    *this = ::std::move(from);
  }

  inline VisionFeatureMessage& operator=(const VisionFeatureMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionFeatureMessage& operator=(VisionFeatureMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionFeatureMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionFeatureMessage* internal_default_instance() {
    return reinterpret_cast<const VisionFeatureMessage*>(
               &_VisionFeatureMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(VisionFeatureMessage& a, VisionFeatureMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionFeatureMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionFeatureMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionFeatureMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionFeatureMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisionFeatureMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VisionFeatureMessage& from) {
    VisionFeatureMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VisionFeatureMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hedgehog.protocol.proto.VisionFeatureMessage";
  }
  protected:
  explicit VisionFeatureMessage(::google::protobuf::Arena* arena);
  VisionFeatureMessage(::google::protobuf::Arena* arena, const VisionFeatureMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelFieldNumber = 1,
    kFeatureFieldNumber = 2,
  };
  // string channel = 1;
  void clear_channel() ;
  const std::string& channel() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel(Arg_&& arg, Args_... args);
  std::string* mutable_channel();
  PROTOBUF_NODISCARD std::string* release_channel();
  void set_allocated_channel(std::string* value);

  private:
  const std::string& _internal_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel(
      const std::string& value);
  std::string* _internal_mutable_channel();

  public:
  // .hedgehog.protocol.proto.Feature feature = 2;
  bool has_feature() const;
  void clear_feature() ;
  const ::hedgehog::protocol::proto::Feature& feature() const;
  PROTOBUF_NODISCARD ::hedgehog::protocol::proto::Feature* release_feature();
  ::hedgehog::protocol::proto::Feature* mutable_feature();
  void set_allocated_feature(::hedgehog::protocol::proto::Feature* value);
  void unsafe_arena_set_allocated_feature(::hedgehog::protocol::proto::Feature* value);
  ::hedgehog::protocol::proto::Feature* unsafe_arena_release_feature();

  private:
  const ::hedgehog::protocol::proto::Feature& _internal_feature() const;
  ::hedgehog::protocol::proto::Feature* _internal_mutable_feature();

  public:
  // @@protoc_insertion_point(class_scope:hedgehog.protocol.proto.VisionFeatureMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr channel_;
    ::hedgehog::protocol::proto::Feature* feature_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hedgehog_2fprotocol_2fproto_2fvision_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// FacesChannel

// -------------------------------------------------------------------

// BlobsChannel

// fixed32 hsv_min = 1;
inline void BlobsChannel::clear_hsv_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hsv_min_ = 0u;
}
inline ::uint32_t BlobsChannel::hsv_min() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.BlobsChannel.hsv_min)
  return _internal_hsv_min();
}
inline void BlobsChannel::set_hsv_min(::uint32_t value) {
  _internal_set_hsv_min(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.BlobsChannel.hsv_min)
}
inline ::uint32_t BlobsChannel::_internal_hsv_min() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hsv_min_;
}
inline void BlobsChannel::_internal_set_hsv_min(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hsv_min_ = value;
}

// fixed32 hsv_max = 2;
inline void BlobsChannel::clear_hsv_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hsv_max_ = 0u;
}
inline ::uint32_t BlobsChannel::hsv_max() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.BlobsChannel.hsv_max)
  return _internal_hsv_max();
}
inline void BlobsChannel::set_hsv_max(::uint32_t value) {
  _internal_set_hsv_max(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.BlobsChannel.hsv_max)
}
inline ::uint32_t BlobsChannel::_internal_hsv_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hsv_max_;
}
inline void BlobsChannel::_internal_set_hsv_max(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hsv_max_ = value;
}

// -------------------------------------------------------------------

// Channel

// string key = 1;
inline void Channel::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& Channel::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Channel.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Channel::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.Channel.key)
}
inline std::string* Channel::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.Channel.key)
  return _s;
}
inline const std::string& Channel::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void Channel::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* Channel::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* Channel::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.Channel.key)
  return _impl_.key_.Release();
}
inline void Channel::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hedgehog.protocol.proto.Channel.key)
}

// .hedgehog.protocol.proto.FacesChannel faces = 2;
inline bool Channel::has_faces() const {
  return channel_case() == kFaces;
}
inline bool Channel::_internal_has_faces() const {
  return channel_case() == kFaces;
}
inline void Channel::set_has_faces() {
  _impl_._oneof_case_[0] = kFaces;
}
inline void Channel::clear_faces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (channel_case() == kFaces) {
    if (GetArena() == nullptr) {
      delete _impl_.channel_.faces_;
    }
    clear_has_channel();
  }
}
inline ::hedgehog::protocol::proto::FacesChannel* Channel::release_faces() {
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.Channel.faces)
  if (channel_case() == kFaces) {
    clear_has_channel();
    auto* temp = _impl_.channel_.faces_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.channel_.faces_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hedgehog::protocol::proto::FacesChannel& Channel::_internal_faces() const {
  return channel_case() == kFaces ? *_impl_.channel_.faces_ : reinterpret_cast<::hedgehog::protocol::proto::FacesChannel&>(::hedgehog::protocol::proto::_FacesChannel_default_instance_);
}
inline const ::hedgehog::protocol::proto::FacesChannel& Channel::faces() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Channel.faces)
  return _internal_faces();
}
inline ::hedgehog::protocol::proto::FacesChannel* Channel::unsafe_arena_release_faces() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hedgehog.protocol.proto.Channel.faces)
  if (channel_case() == kFaces) {
    clear_has_channel();
    auto* temp = _impl_.channel_.faces_;
    _impl_.channel_.faces_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Channel::unsafe_arena_set_allocated_faces(::hedgehog::protocol::proto::FacesChannel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_channel();
  if (value) {
    set_has_faces();
    _impl_.channel_.faces_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hedgehog.protocol.proto.Channel.faces)
}
inline ::hedgehog::protocol::proto::FacesChannel* Channel::_internal_mutable_faces() {
  if (channel_case() != kFaces) {
    clear_channel();
    set_has_faces();
    _impl_.channel_.faces_ = CreateMaybeMessage<::hedgehog::protocol::proto::FacesChannel>(GetArena());
  }
  return _impl_.channel_.faces_;
}
inline ::hedgehog::protocol::proto::FacesChannel* Channel::mutable_faces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hedgehog::protocol::proto::FacesChannel* _msg = _internal_mutable_faces();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.Channel.faces)
  return _msg;
}

// .hedgehog.protocol.proto.BlobsChannel blobs = 3;
inline bool Channel::has_blobs() const {
  return channel_case() == kBlobs;
}
inline bool Channel::_internal_has_blobs() const {
  return channel_case() == kBlobs;
}
inline void Channel::set_has_blobs() {
  _impl_._oneof_case_[0] = kBlobs;
}
inline void Channel::clear_blobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (channel_case() == kBlobs) {
    if (GetArena() == nullptr) {
      delete _impl_.channel_.blobs_;
    }
    clear_has_channel();
  }
}
inline ::hedgehog::protocol::proto::BlobsChannel* Channel::release_blobs() {
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.Channel.blobs)
  if (channel_case() == kBlobs) {
    clear_has_channel();
    auto* temp = _impl_.channel_.blobs_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.channel_.blobs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hedgehog::protocol::proto::BlobsChannel& Channel::_internal_blobs() const {
  return channel_case() == kBlobs ? *_impl_.channel_.blobs_ : reinterpret_cast<::hedgehog::protocol::proto::BlobsChannel&>(::hedgehog::protocol::proto::_BlobsChannel_default_instance_);
}
inline const ::hedgehog::protocol::proto::BlobsChannel& Channel::blobs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Channel.blobs)
  return _internal_blobs();
}
inline ::hedgehog::protocol::proto::BlobsChannel* Channel::unsafe_arena_release_blobs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hedgehog.protocol.proto.Channel.blobs)
  if (channel_case() == kBlobs) {
    clear_has_channel();
    auto* temp = _impl_.channel_.blobs_;
    _impl_.channel_.blobs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Channel::unsafe_arena_set_allocated_blobs(::hedgehog::protocol::proto::BlobsChannel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_channel();
  if (value) {
    set_has_blobs();
    _impl_.channel_.blobs_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hedgehog.protocol.proto.Channel.blobs)
}
inline ::hedgehog::protocol::proto::BlobsChannel* Channel::_internal_mutable_blobs() {
  if (channel_case() != kBlobs) {
    clear_channel();
    set_has_blobs();
    _impl_.channel_.blobs_ = CreateMaybeMessage<::hedgehog::protocol::proto::BlobsChannel>(GetArena());
  }
  return _impl_.channel_.blobs_;
}
inline ::hedgehog::protocol::proto::BlobsChannel* Channel::mutable_blobs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hedgehog::protocol::proto::BlobsChannel* _msg = _internal_mutable_blobs();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.Channel.blobs)
  return _msg;
}

inline bool Channel::has_channel() const {
  return channel_case() != CHANNEL_NOT_SET;
}
inline void Channel::clear_has_channel() {
  _impl_._oneof_case_[0] = CHANNEL_NOT_SET;
}
inline Channel::ChannelCase Channel::channel_case() const {
  return Channel::ChannelCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Face

// int32 x = 1;
inline void Face::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline ::int32_t Face::x() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Face.x)
  return _internal_x();
}
inline void Face::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.Face.x)
}
inline ::int32_t Face::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Face::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// int32 y = 2;
inline void Face::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline ::int32_t Face::y() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Face.y)
  return _internal_y();
}
inline void Face::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.Face.y)
}
inline ::int32_t Face::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Face::_internal_set_y(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// int32 width = 3;
inline void Face::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
}
inline ::int32_t Face::width() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Face.width)
  return _internal_width();
}
inline void Face::set_width(::int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.Face.width)
}
inline ::int32_t Face::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void Face::_internal_set_width(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.width_ = value;
}

// int32 height = 4;
inline void Face::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0;
}
inline ::int32_t Face::height() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Face.height)
  return _internal_height();
}
inline void Face::set_height(::int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.Face.height)
}
inline ::int32_t Face::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void Face::_internal_set_height(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.height_ = value;
}

// -------------------------------------------------------------------

// FacesFeature

// repeated .hedgehog.protocol.proto.Face faces = 1;
inline int FacesFeature::_internal_faces_size() const {
  return _internal_faces().size();
}
inline int FacesFeature::faces_size() const {
  return _internal_faces_size();
}
inline void FacesFeature::clear_faces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.faces_.Clear();
}
inline ::hedgehog::protocol::proto::Face* FacesFeature::mutable_faces(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.FacesFeature.faces)
  return _internal_mutable_faces()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Face>* FacesFeature::mutable_faces()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hedgehog.protocol.proto.FacesFeature.faces)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_faces();
}
inline const ::hedgehog::protocol::proto::Face& FacesFeature::faces(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.FacesFeature.faces)
  return _internal_faces().Get(index);
}
inline ::hedgehog::protocol::proto::Face* FacesFeature::add_faces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::hedgehog::protocol::proto::Face* _add = _internal_mutable_faces()->Add();
  // @@protoc_insertion_point(field_add:hedgehog.protocol.proto.FacesFeature.faces)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Face>& FacesFeature::faces() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hedgehog.protocol.proto.FacesFeature.faces)
  return _internal_faces();
}
inline const ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Face>&
FacesFeature::_internal_faces() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.faces_;
}
inline ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Face>*
FacesFeature::_internal_mutable_faces() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.faces_;
}

// -------------------------------------------------------------------

// Blob

// int32 x = 1;
inline void Blob::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline ::int32_t Blob::x() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Blob.x)
  return _internal_x();
}
inline void Blob::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.Blob.x)
}
inline ::int32_t Blob::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Blob::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// int32 y = 2;
inline void Blob::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline ::int32_t Blob::y() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Blob.y)
  return _internal_y();
}
inline void Blob::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.Blob.y)
}
inline ::int32_t Blob::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Blob::_internal_set_y(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// int32 width = 3;
inline void Blob::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
}
inline ::int32_t Blob::width() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Blob.width)
  return _internal_width();
}
inline void Blob::set_width(::int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.Blob.width)
}
inline ::int32_t Blob::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void Blob::_internal_set_width(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.width_ = value;
}

// int32 height = 4;
inline void Blob::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0;
}
inline ::int32_t Blob::height() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Blob.height)
  return _internal_height();
}
inline void Blob::set_height(::int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.Blob.height)
}
inline ::int32_t Blob::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void Blob::_internal_set_height(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.height_ = value;
}

// int32 cx = 5;
inline void Blob::clear_cx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cx_ = 0;
}
inline ::int32_t Blob::cx() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Blob.cx)
  return _internal_cx();
}
inline void Blob::set_cx(::int32_t value) {
  _internal_set_cx(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.Blob.cx)
}
inline ::int32_t Blob::_internal_cx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cx_;
}
inline void Blob::_internal_set_cx(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cx_ = value;
}

// int32 cy = 6;
inline void Blob::clear_cy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cy_ = 0;
}
inline ::int32_t Blob::cy() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Blob.cy)
  return _internal_cy();
}
inline void Blob::set_cy(::int32_t value) {
  _internal_set_cy(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.Blob.cy)
}
inline ::int32_t Blob::_internal_cy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cy_;
}
inline void Blob::_internal_set_cy(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cy_ = value;
}

// float confidence = 7;
inline void Blob::clear_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.confidence_ = 0;
}
inline float Blob::confidence() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Blob.confidence)
  return _internal_confidence();
}
inline void Blob::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.Blob.confidence)
}
inline float Blob::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.confidence_;
}
inline void Blob::_internal_set_confidence(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.confidence_ = value;
}

// -------------------------------------------------------------------

// BlobsFeature

// repeated .hedgehog.protocol.proto.Blob blobs = 1;
inline int BlobsFeature::_internal_blobs_size() const {
  return _internal_blobs().size();
}
inline int BlobsFeature::blobs_size() const {
  return _internal_blobs_size();
}
inline void BlobsFeature::clear_blobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blobs_.Clear();
}
inline ::hedgehog::protocol::proto::Blob* BlobsFeature::mutable_blobs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.BlobsFeature.blobs)
  return _internal_mutable_blobs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Blob>* BlobsFeature::mutable_blobs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hedgehog.protocol.proto.BlobsFeature.blobs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_blobs();
}
inline const ::hedgehog::protocol::proto::Blob& BlobsFeature::blobs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.BlobsFeature.blobs)
  return _internal_blobs().Get(index);
}
inline ::hedgehog::protocol::proto::Blob* BlobsFeature::add_blobs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::hedgehog::protocol::proto::Blob* _add = _internal_mutable_blobs()->Add();
  // @@protoc_insertion_point(field_add:hedgehog.protocol.proto.BlobsFeature.blobs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Blob>& BlobsFeature::blobs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hedgehog.protocol.proto.BlobsFeature.blobs)
  return _internal_blobs();
}
inline const ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Blob>&
BlobsFeature::_internal_blobs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blobs_;
}
inline ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Blob>*
BlobsFeature::_internal_mutable_blobs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.blobs_;
}

// -------------------------------------------------------------------

// Feature

// .hedgehog.protocol.proto.FacesFeature faces = 1;
inline bool Feature::has_faces() const {
  return feature_case() == kFaces;
}
inline bool Feature::_internal_has_faces() const {
  return feature_case() == kFaces;
}
inline void Feature::set_has_faces() {
  _impl_._oneof_case_[0] = kFaces;
}
inline void Feature::clear_faces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (feature_case() == kFaces) {
    if (GetArena() == nullptr) {
      delete _impl_.feature_.faces_;
    }
    clear_has_feature();
  }
}
inline ::hedgehog::protocol::proto::FacesFeature* Feature::release_faces() {
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.Feature.faces)
  if (feature_case() == kFaces) {
    clear_has_feature();
    auto* temp = _impl_.feature_.faces_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.feature_.faces_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hedgehog::protocol::proto::FacesFeature& Feature::_internal_faces() const {
  return feature_case() == kFaces ? *_impl_.feature_.faces_ : reinterpret_cast<::hedgehog::protocol::proto::FacesFeature&>(::hedgehog::protocol::proto::_FacesFeature_default_instance_);
}
inline const ::hedgehog::protocol::proto::FacesFeature& Feature::faces() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Feature.faces)
  return _internal_faces();
}
inline ::hedgehog::protocol::proto::FacesFeature* Feature::unsafe_arena_release_faces() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hedgehog.protocol.proto.Feature.faces)
  if (feature_case() == kFaces) {
    clear_has_feature();
    auto* temp = _impl_.feature_.faces_;
    _impl_.feature_.faces_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_faces(::hedgehog::protocol::proto::FacesFeature* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_feature();
  if (value) {
    set_has_faces();
    _impl_.feature_.faces_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hedgehog.protocol.proto.Feature.faces)
}
inline ::hedgehog::protocol::proto::FacesFeature* Feature::_internal_mutable_faces() {
  if (feature_case() != kFaces) {
    clear_feature();
    set_has_faces();
    _impl_.feature_.faces_ = CreateMaybeMessage<::hedgehog::protocol::proto::FacesFeature>(GetArena());
  }
  return _impl_.feature_.faces_;
}
inline ::hedgehog::protocol::proto::FacesFeature* Feature::mutable_faces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hedgehog::protocol::proto::FacesFeature* _msg = _internal_mutable_faces();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.Feature.faces)
  return _msg;
}

// .hedgehog.protocol.proto.BlobsFeature blobs = 2;
inline bool Feature::has_blobs() const {
  return feature_case() == kBlobs;
}
inline bool Feature::_internal_has_blobs() const {
  return feature_case() == kBlobs;
}
inline void Feature::set_has_blobs() {
  _impl_._oneof_case_[0] = kBlobs;
}
inline void Feature::clear_blobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (feature_case() == kBlobs) {
    if (GetArena() == nullptr) {
      delete _impl_.feature_.blobs_;
    }
    clear_has_feature();
  }
}
inline ::hedgehog::protocol::proto::BlobsFeature* Feature::release_blobs() {
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.Feature.blobs)
  if (feature_case() == kBlobs) {
    clear_has_feature();
    auto* temp = _impl_.feature_.blobs_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.feature_.blobs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::hedgehog::protocol::proto::BlobsFeature& Feature::_internal_blobs() const {
  return feature_case() == kBlobs ? *_impl_.feature_.blobs_ : reinterpret_cast<::hedgehog::protocol::proto::BlobsFeature&>(::hedgehog::protocol::proto::_BlobsFeature_default_instance_);
}
inline const ::hedgehog::protocol::proto::BlobsFeature& Feature::blobs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.Feature.blobs)
  return _internal_blobs();
}
inline ::hedgehog::protocol::proto::BlobsFeature* Feature::unsafe_arena_release_blobs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hedgehog.protocol.proto.Feature.blobs)
  if (feature_case() == kBlobs) {
    clear_has_feature();
    auto* temp = _impl_.feature_.blobs_;
    _impl_.feature_.blobs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_blobs(::hedgehog::protocol::proto::BlobsFeature* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_feature();
  if (value) {
    set_has_blobs();
    _impl_.feature_.blobs_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hedgehog.protocol.proto.Feature.blobs)
}
inline ::hedgehog::protocol::proto::BlobsFeature* Feature::_internal_mutable_blobs() {
  if (feature_case() != kBlobs) {
    clear_feature();
    set_has_blobs();
    _impl_.feature_.blobs_ = CreateMaybeMessage<::hedgehog::protocol::proto::BlobsFeature>(GetArena());
  }
  return _impl_.feature_.blobs_;
}
inline ::hedgehog::protocol::proto::BlobsFeature* Feature::mutable_blobs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hedgehog::protocol::proto::BlobsFeature* _msg = _internal_mutable_blobs();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.Feature.blobs)
  return _msg;
}

inline bool Feature::has_feature() const {
  return feature_case() != FEATURE_NOT_SET;
}
inline void Feature::clear_has_feature() {
  _impl_._oneof_case_[0] = FEATURE_NOT_SET;
}
inline Feature::FeatureCase Feature::feature_case() const {
  return Feature::FeatureCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VisionCameraAction

// bool open = 1;
inline void VisionCameraAction::clear_open() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.open_ = false;
}
inline bool VisionCameraAction::open() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.VisionCameraAction.open)
  return _internal_open();
}
inline void VisionCameraAction::set_open(bool value) {
  _internal_set_open(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.VisionCameraAction.open)
}
inline bool VisionCameraAction::_internal_open() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.open_;
}
inline void VisionCameraAction::_internal_set_open(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.open_ = value;
}

// -------------------------------------------------------------------

// VisionChannelMessage

// .hedgehog.protocol.proto.ChannelOperation op = 1;
inline void VisionChannelMessage::clear_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_ = 0;
}
inline ::hedgehog::protocol::proto::ChannelOperation VisionChannelMessage::op() const {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.VisionChannelMessage.op)
  return _internal_op();
}
inline void VisionChannelMessage::set_op(::hedgehog::protocol::proto::ChannelOperation value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.VisionChannelMessage.op)
}
inline ::hedgehog::protocol::proto::ChannelOperation VisionChannelMessage::_internal_op() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::hedgehog::protocol::proto::ChannelOperation>(_impl_.op_);
}
inline void VisionChannelMessage::_internal_set_op(::hedgehog::protocol::proto::ChannelOperation value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.op_ = value;
}

// repeated .hedgehog.protocol.proto.Channel channels = 2;
inline int VisionChannelMessage::_internal_channels_size() const {
  return _internal_channels().size();
}
inline int VisionChannelMessage::channels_size() const {
  return _internal_channels_size();
}
inline void VisionChannelMessage::clear_channels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channels_.Clear();
}
inline ::hedgehog::protocol::proto::Channel* VisionChannelMessage::mutable_channels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.VisionChannelMessage.channels)
  return _internal_mutable_channels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Channel>* VisionChannelMessage::mutable_channels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:hedgehog.protocol.proto.VisionChannelMessage.channels)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_channels();
}
inline const ::hedgehog::protocol::proto::Channel& VisionChannelMessage::channels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.VisionChannelMessage.channels)
  return _internal_channels().Get(index);
}
inline ::hedgehog::protocol::proto::Channel* VisionChannelMessage::add_channels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::hedgehog::protocol::proto::Channel* _add = _internal_mutable_channels()->Add();
  // @@protoc_insertion_point(field_add:hedgehog.protocol.proto.VisionChannelMessage.channels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Channel>& VisionChannelMessage::channels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:hedgehog.protocol.proto.VisionChannelMessage.channels)
  return _internal_channels();
}
inline const ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Channel>&
VisionChannelMessage::_internal_channels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channels_;
}
inline ::google::protobuf::RepeatedPtrField<::hedgehog::protocol::proto::Channel>*
VisionChannelMessage::_internal_mutable_channels() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.channels_;
}

// -------------------------------------------------------------------

// VisionCaptureFrameAction

// -------------------------------------------------------------------

// VisionFrameMessage

// string highlight = 1;
inline void VisionFrameMessage::clear_highlight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.highlight_.ClearToEmpty();
}
inline const std::string& VisionFrameMessage::highlight() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.VisionFrameMessage.highlight)
  return _internal_highlight();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisionFrameMessage::set_highlight(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.highlight_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.VisionFrameMessage.highlight)
}
inline std::string* VisionFrameMessage::mutable_highlight() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_highlight();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.VisionFrameMessage.highlight)
  return _s;
}
inline const std::string& VisionFrameMessage::_internal_highlight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.highlight_.Get();
}
inline void VisionFrameMessage::_internal_set_highlight(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.highlight_.Set(value, GetArena());
}
inline std::string* VisionFrameMessage::_internal_mutable_highlight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.highlight_.Mutable( GetArena());
}
inline std::string* VisionFrameMessage::release_highlight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.VisionFrameMessage.highlight)
  return _impl_.highlight_.Release();
}
inline void VisionFrameMessage::set_allocated_highlight(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.highlight_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.highlight_.IsDefault()) {
          _impl_.highlight_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hedgehog.protocol.proto.VisionFrameMessage.highlight)
}

// bytes frame = 2;
inline void VisionFrameMessage::clear_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_.ClearToEmpty();
}
inline const std::string& VisionFrameMessage::frame() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.VisionFrameMessage.frame)
  return _internal_frame();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisionFrameMessage::set_frame(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.frame_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.VisionFrameMessage.frame)
}
inline std::string* VisionFrameMessage::mutable_frame() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.VisionFrameMessage.frame)
  return _s;
}
inline const std::string& VisionFrameMessage::_internal_frame() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame_.Get();
}
inline void VisionFrameMessage::_internal_set_frame(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.frame_.Set(value, GetArena());
}
inline std::string* VisionFrameMessage::_internal_mutable_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.frame_.Mutable( GetArena());
}
inline std::string* VisionFrameMessage::release_frame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.VisionFrameMessage.frame)
  return _impl_.frame_.Release();
}
inline void VisionFrameMessage::set_allocated_frame(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.frame_.IsDefault()) {
          _impl_.frame_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hedgehog.protocol.proto.VisionFrameMessage.frame)
}

// -------------------------------------------------------------------

// VisionFeatureMessage

// string channel = 1;
inline void VisionFeatureMessage::clear_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_.ClearToEmpty();
}
inline const std::string& VisionFeatureMessage::channel() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.VisionFeatureMessage.channel)
  return _internal_channel();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisionFeatureMessage::set_channel(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:hedgehog.protocol.proto.VisionFeatureMessage.channel)
}
inline std::string* VisionFeatureMessage::mutable_channel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.VisionFeatureMessage.channel)
  return _s;
}
inline const std::string& VisionFeatureMessage::_internal_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_.Get();
}
inline void VisionFeatureMessage::_internal_set_channel(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_.Set(value, GetArena());
}
inline std::string* VisionFeatureMessage::_internal_mutable_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.channel_.Mutable( GetArena());
}
inline std::string* VisionFeatureMessage::release_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.VisionFeatureMessage.channel)
  return _impl_.channel_.Release();
}
inline void VisionFeatureMessage::set_allocated_channel(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_.IsDefault()) {
          _impl_.channel_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hedgehog.protocol.proto.VisionFeatureMessage.channel)
}

// .hedgehog.protocol.proto.Feature feature = 2;
inline bool VisionFeatureMessage::has_feature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.feature_ != nullptr);
  return value;
}
inline void VisionFeatureMessage::clear_feature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.feature_ != nullptr) _impl_.feature_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hedgehog::protocol::proto::Feature& VisionFeatureMessage::_internal_feature() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::hedgehog::protocol::proto::Feature* p = _impl_.feature_;
  return p != nullptr ? *p : reinterpret_cast<const ::hedgehog::protocol::proto::Feature&>(::hedgehog::protocol::proto::_Feature_default_instance_);
}
inline const ::hedgehog::protocol::proto::Feature& VisionFeatureMessage::feature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:hedgehog.protocol.proto.VisionFeatureMessage.feature)
  return _internal_feature();
}
inline void VisionFeatureMessage::unsafe_arena_set_allocated_feature(::hedgehog::protocol::proto::Feature* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.feature_);
  }
  _impl_.feature_ = reinterpret_cast<::hedgehog::protocol::proto::Feature*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hedgehog.protocol.proto.VisionFeatureMessage.feature)
}
inline ::hedgehog::protocol::proto::Feature* VisionFeatureMessage::release_feature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hedgehog::protocol::proto::Feature* released = _impl_.feature_;
  _impl_.feature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::hedgehog::protocol::proto::Feature* VisionFeatureMessage::unsafe_arena_release_feature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:hedgehog.protocol.proto.VisionFeatureMessage.feature)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hedgehog::protocol::proto::Feature* temp = _impl_.feature_;
  _impl_.feature_ = nullptr;
  return temp;
}
inline ::hedgehog::protocol::proto::Feature* VisionFeatureMessage::_internal_mutable_feature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.feature_ == nullptr) {
    auto* p = CreateMaybeMessage<::hedgehog::protocol::proto::Feature>(GetArena());
    _impl_.feature_ = reinterpret_cast<::hedgehog::protocol::proto::Feature*>(p);
  }
  return _impl_.feature_;
}
inline ::hedgehog::protocol::proto::Feature* VisionFeatureMessage::mutable_feature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::hedgehog::protocol::proto::Feature* _msg = _internal_mutable_feature();
  // @@protoc_insertion_point(field_mutable:hedgehog.protocol.proto.VisionFeatureMessage.feature)
  return _msg;
}
inline void VisionFeatureMessage::set_allocated_feature(::hedgehog::protocol::proto::Feature* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::hedgehog::protocol::proto::Feature*>(_impl_.feature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::hedgehog::protocol::proto::Feature*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.feature_ = reinterpret_cast<::hedgehog::protocol::proto::Feature*>(value);
  // @@protoc_insertion_point(field_set_allocated:hedgehog.protocol.proto.VisionFeatureMessage.feature)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace protocol
}  // namespace hedgehog


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::hedgehog::protocol::proto::ChannelOperation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::hedgehog::protocol::proto::ChannelOperation>() {
  return ::hedgehog::protocol::proto::ChannelOperation_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_hedgehog_2fprotocol_2fproto_2fvision_2eproto_2epb_2eh
